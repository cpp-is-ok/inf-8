\documentclass{article}
\usepackage[english,russian]{babel}
\usepackage[left=10mm, top=0mm, right=10mm, bottom=15mm, includehead]{geometry}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{graphbox}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{tabularx}
\usepackage{float}
\DeclareTextSymbol{\cyrm}{\LastDeclaredEncoding}{236}
\DeclareTextSymbol{\cyrk}{\LastDeclaredEncoding}{234}
\graphicspath{ {./images/} }
\setcounter{tocdepth}{3}

\newcommand{\image}[2]{\includegraphics[height=#2]{images/#1.png}}
\newcommand{\imagen}[1]{\includegraphics{images/#1.png}}
\newcommand{\tab}{\ \ \ \:}
\newcommand{\Ohm}{\mathrm{\ \Omega}}
\newcommand{\kOhm}{\ \textrm{\cyrk}\Omega}
\newcommand{\V}{\mathrm{\ B}}
\newcommand{\A}{\mathrm{\ A}}
\newcommand{\mA}{\mathrm{\ \textrm{\cyrm} A}}
\newcommand{\p}{\varphi}
\newcommand{\tabularII}[1]{\begin{center}\begin{tabular}{|c|c|} #1 \end{tabular}\end{center}}
\newcommand{\tabularIII}[1]{\begin{center}\begin{tabular}{|c|c|c|} #1 \end{tabular}\end{center}}

\newcommand{\mathhelp}[1]{\textbf{\colorbox[rgb]{0.9,0.9,1}{Математическая справка}}. #1}
\newcommand{\stat}[1]{\textbf{Утверждение}. #1}
\newcommand{\style}[1]{\textbf{\colorbox[rgb]{0.9,1,0.9}{Стилистическая заметка}}. #1}
\newcommand{\important}[1]{\textbf{\colorbox[rgb]{1,0.9,0.9}{Важно}!} #1}
\newcommand{\note}[1]{\textbf{\colorbox[rgb]{1,1,0.9}{Замечание}}. #1}
\newcommand{\task}[1]{\textbf{Задача}. #1}
\newcommand{\exercise}[1]{\textbf{Упражнение}. #1}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\title{Язык C++}

\begin{document}
	\lstset{language=C++, tabsize=4, numbers=left,  backgroundcolor=\color{backcolour},		commentstyle=\color{codegreen}, keywordstyle=\color{magenta}, numberstyle=\tiny\color{codegray}, stringstyle=\color{codepurple},	basicstyle=\ttfamily\footnotesize}
	
	\maketitle
	\tableofcontents
	\newpage
	
	\section{Начало}
	
	\subsection{О структуре}
	
	Некоторые факты изложены в выделенных секциях. Ниже описано их предназначение.
	
	\mathhelp{Иногда в информатике требуются знания из математики, которые в курсах алгебры, геометрии и спецмата ещё не пройдены к моменту изучения в информатике. Такие факты приводятся в этой секции.}
	
	\style{Соблюдение этих правил настоятельно рекомендуется для поддержания читабельности кода и удобства его понимания. Но, вообще говоря, соблюдение данных правил не обязательно.}
	
	\important{У C++ есть свои странности, о которых важно помнить, чтобы Ваша программа работала так, как Вы хотите.}
	
	\note{Код можно писать и без этой информации, но иногда непонятно, как будет работать код, если сделать что-то не так, как предполагалось. Заметки рассказывают, что будет, если давать инструкции компьютеру не так, как предполагалось. Например, что будет, если делить на $0$?}
	
	\task{Формулируемые для последующего разбора задачи обозначаются так.}
	
	Кроме того, \textit{курсивом} выделены новые термины, а важные, по мнению автора, факты \underline{подчёркнуты}.
	
	В случае ошибок, опечаток, предложений по оформлению и т.д. пишите \href{https://t.me/cpp_is_ok}{@cpp\_is\_ok} в Телеграмм.
	
	В случае вопросов по содержанию или по задачам пишите Боту помощи \href{https://t.me/inf54bot}{@inf54bot}.
	
	\subsection{Шаблон}
	
	Ниже приведён стандартный код на C++:
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	
}
	\end{lstlisting}
	
	Весь код, который мы будем писать в первом полугодии 8 класса, будет находиться внутри фигурных скобок. Пока будем использовать его, не задумываясь, что это значит. Потом мы узнаем, что значат все эти команды. Если в приведённом в этой книге коде отсутствуют команды, начинающиеся с \texttt{\#include}, это значит, что приведённый код находится между фигурными скобками.
	
	\style{Код внутри фигурных скобок \underline{принято писать с отступом в 4 пробела в начале каждой строки}. Скорее всего, редактор кода поможет Вам с поддержанием этого отступа.}
	
	\subsection{Переменные}
	\textit{Переменная} --- это <<коробка>> для хранения чего-либо. У переменной есть:
	\begin{enumerate}
		\item{\textbf{Тип}. Каждая коробка подходит только для одного типа содержимого. Пока мы будем работать с целыми числами --- это один из возможных типов содержимого.}
		\item{\textbf{Значение}. Это и есть то, что лежит в коробке. Например, там может лежать число 54.}
		\item{\textbf{Имя}}. Некоторая последовательность символов, уникальная для каждой переменной. По ней в переменную можно записывать значения и получать значения.
	\end{enumerate}
	
	Каждая инструкция в C++ заканчивается точкой с запятой (\texttt{;}). Чтобы объявить переменную (создать коробку), нужно написать сначала тип переменной, затем её имя. Например, инструкция
	
	\begin{lstlisting}
int a;
	\end{lstlisting}
	
	создаёт переменную с именем \texttt{a} типа целое число (\texttt{int} от англ. integer --- целое). В названии можно использовать любые английские буквы (как заглавные, так и строчные), нижнее подчеркивание (\_) и цифры, но название не может начинаться с цифры. Название переменной может содержать любое количество символов. Название переменной не должно совпадать с ключевыми словами (с ними мы будем постепенно знакомиться в следующих главах) и типами данных. В таблице ниже приведены примеры корректных и некорректных имён переменных.
	
	\tabularII{
		\hline
		\textbf{Корректные} & \textbf{Некорректные}\\
		\hline
		a2 & 2a\\
		\hline
		number\_of\_letters & number-of-letters\\
		\hline
		numberOfLetters & number of letters\\
		\hline
		int\_ & int\\
		\hline
	}
	
	\style{Хорошо давать переменным имена, из которых следует содержимое переменных. Исключением является размер входных данных: если в условии сказано, что программе будет передано некоторое количество целых чисел, то это количество обычно обозначается $n$.}
	
	Чтобы присвоить значение переменной (положить что-либо в коробку, \underline{навсегда утратив} предыдущее её содержимое), нужно написать через равно имя переменной и новое её значение. Например, чтобы присвоить уже объявленной переменной \texttt{a} число 54, нужно написать:
	
	\begin{lstlisting}
a = 54;
	\end{lstlisting}
	
	Таким образом, чтобы объявить переменную \texttt{letter\_num} и присвоить ей значение 5, нужно написать:
	
	\begin{lstlisting}
int letter_num;
letter_num = 5;
	\end{lstlisting}
	
	Вместо этого есть более короткая запись:
	
	\begin{lstlisting}
int letter_num = 5;
	\end{lstlisting}
	
	Можно объявлять несколько переменных одного типа в одной строке:
	
	\begin{lstlisting}
int a, b = 5, c = 4;
	\end{lstlisting}
	
	Эта строка объявляет переменные \texttt{a}, \texttt{b} и \texttt{c}. Переменным \texttt{b} и \texttt{c} заданы значения (5 и 4 соответственно). Переменная \texttt{a} создана, но \textit{не инициализирована}. Это значит, что в ней может храниться любое значение, пока оно не будет задано явно. Используя \texttt{равно}, можно и сохранять значение одной переменной в другую. Например, если в переменной \texttt{b} хранится значение 54, то после инструкции
	
	\begin{lstlisting}
int a = b;
	\end{lstlisting}
	
	будет создана переменная \texttt{a}, в которой тоже будет храниться число 54.
	
	Когда некоторое число используется в коде несколько раз, то хорошим стилем написания кода является определение \textit{константы}. Это переменная, значение которой может быть присвоено только при создании. При попытке далее в программе изменить значение константы, то программа не будет запущена, что гарантирует сохранность одного значения на протяжении всего выполнения кода.
	
	Чтобы объявить константу, перед названием типа надо написать \texttt{const}:
	
	\begin{lstlisting}
const int SYSTEM_BASE = 10;
	\end{lstlisting}
	
	\style{Для именования констант используют только заглавные буквы и нижние подчёркивания, как в примере выше.}
	
	\subsection{Арифметические операции}
	
	В данном параграфе мы научимся совершать арифметические операции --- сложение, вычитание, умножение, деление, остаток от деления. В таблице ниже приведены обозначения этих операций в C++:
	
	\tabularII{
		\hline
		сложение & +\\
		\hline
		вычитание & -\\
		\hline
		умножение & *\\
		\hline
		деление & /\\
		\hline
		остаток от деления & \%\\
		\hline
	}
	
	Эти операции можно совершать как с числами, так и с переменными. В одном выражении можно использовать и числа, и переменные. Порядок действий по умолчанию --- как в математике (приоритет остатка от деления такой же, как у деления). Чтобы повлиять на порядок действий, можно использовать круглые скобки.
	
	\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/} --- это \textit{бинарные операторы}. Это значит, что они совершают некоторое действие с двумя \textit{операндами} --- теми объектами, которые они разделяют. На самом деле, \texttt{=} --- тоже бинарный оператор, называемый \textit{оператором присваивания}.
	
	Следующий код сохраняет числа 5 и 4 в переменные \texttt{a} и \texttt{b}, а затем сохраняет их сумму в переменную \texttt{c}.
	
	\begin{lstlisting}
#include<iostream>

using namespace std;

int main() {
	int a = 5, b = 4;
	int c = a + b;
}
	\end{lstlisting}
	
	\style{Хорошо ставить пробелы с обеих сторон от оператора, как в примере выше. Также пробел ставится после запятой, но не до неё.}
	
	\mathhelp{\textit{Разделить} целое число $a$ на натуральное число $b$ \textit{с остатком} значит представить $a$ в виде $qb+r$, где $q$ и $r$ целые, и $0\le r < b$. Тогда число $q$ называется \textit{неполным частным}, а число $r$ \textit{остатком} при делении числа $a$ на число $b$.}
	
	Операция деления (\texttt{/}) над целыми числами возвращает именно \textbf{неполное частное}. Например, \texttt{5/2} равно $2$.
	
	\important{При делении отрицательного числа C++ не соблюдает правила математики. Он делает операции так, будто это положительное число, а затем добавляет неполному частному и остатку знак минус. Например, $(-5) \% 3 = -2$, $(-5) / 3 = -1$.}
	
	Если Вам нужен остаток от деления, как в математике, для деления $a$ на $b$ можно использовать следующую конструкцию:
	
	\begin{lstlisting}
((a % b) + b) % b
	\end{lstlisting}
	
	Кроме того, есть \textit{унарный оператор} $-$. Это значит, что он совершает операцию, имеющую только один операнд (который идет после оператора). При таком использовании он меняет знак у операнда. Например, после выполнения кода
	
	\begin{lstlisting}
int a = 5;
int b = -a;
	\end{lstlisting}
	
	в переменной \texttt{b} будет храниться число $-5$.
	
	\subsection{Обработка цифр числа}
	
	Решим следующую задачу:
	
	\task{Дано натуральное двузначное число $x$. Найдите сумму его цифр.}
	
	Чтобы это сделать, научимся совершать с числом два следующих действия:
	
	\begin{enumerate}
		\item{Узнать последнюю цифру числа (разряд единиц);}
		\item{Удалить из числа последнюю цифру.}
	\end{enumerate}
	
	\mathhelp{Если над некоторым набором переменных стоит палочка, это значит, что рассматривается число, цифры которого --- значения переменных. Например, если $a=5, b=4$, то $\overline{ab}=54$. Палочка используется для того, чтобы не путать запись цифр числа и перемножение.}
	
	Рассмотрим некоторое натуральное число $a=\overline{a_n a_{n - 1}\dots a_0}$. Разложим его на разрядные слагаемые. Тогда $a=a_n \cdot 10^n + a_{n - 1} \cdot 10^{n - 1} + \dots + a_0 = 10 (a_n \cdot 10^{n - 1} + a_{n - 1} \cdot 10^{n - 2} + \dots + a_1) + a_0=10\overline{a_n a_{n - 1} \dots a_1} + a_0$. $a_0 < 10$, и $\overline{a_n a_{n - 1} \dots a_1}$ и $a_0$ целые, поэтому по определению деления с остатком $a_0$ --- остаток, $\overline{a_n a_{n - 1}\dots a_1}$ --- неполное частное при делении на $10$.
	
	\subsection{Про тип данных \texttt{long long}}
	
	В п. 1.2 мы познакомились с типом данных \texttt{int}. На самом деле, он умеет вмещать в себя только числа в диапазоне $[-2^{31}; 2^{31} -1]$ (примерно от $-2\cdot 10^9$ до $2\cdot 10^9$). Но часто требуется работать с б$\acute{\operatorname{o}}$льшими числами. Тип данных \texttt{long long} позволяет работать с числами в диапазоне $[-2^{63}; 2^{63}-1]$ (примерно от $-9\cdot 10^{18}$ до $9\cdot 10^{18}$). Операции над типом \texttt{long long} совершаются так же, как и над типом \texttt{int}. Но помните, что при перемножении двух чисел типа \texttt{int} результат будет считаться тоже в типе int. Поэтому следующий код содержит ошибку:
	
	\begin{lstlisting}
int a = 1000000000;
long long b = a * a;
	\end{lstlisting}
	
	Результат перемножения считается в типе \texttt{int}, в который не помещается. Есть несколько возможных способов исправления этой ошибки:
	
	\begin{lstlisting}
long long a = 1000000000;
long long b = a * a;
	\end{lstlisting}
	
	или
	\begin{lstlisting}
int a = 1000000000;
long long b = 1ll * a * a;
	\end{lstlisting}
	
	Обратите внимание, что если после числа написано \texttt{ll}, то оно имеет тип \texttt{long long}. Если умножить \texttt{int} на \texttt{long long}, то получится \texttt{long long}. Поэтому первое умножение в коде выше приведет \texttt{a} к типу \texttt{long long}.
	
	\subsection{Ввод-вывод}
	
	Обычно от программы требуется какое-либо взаимодействие с пользователем. Поэтому в C++, как и во всех  других языках программирования, реализован ввод с клавиатуры и вывод на экран. Доступ к вводу осуществляется через \texttt{cin} (от англ. console input --- консольный ввод) --- особый объект. Чтобы считать число, например, в переменную \texttt{a}, нужно написать следующую инструкцию:
	
	\begin{lstlisting}
cin >> a;
	\end{lstlisting}
	
	(Помните, что перед работой с переменной её надо обязательно объявить!)
	
	Кроме того, можно считывать несколько чисел одной инструкцией:
	
	\begin{lstlisting}
cin >> a >> b >> c;
	\end{lstlisting}
	
	При этом при вводе числа могут разделяться как переводами строк (Enter), так и пробелами.
	
	Для вывода используется другой объект --- \texttt{cout} (от англ. console output --- консольный вывод). Чтобы вывести содержимое переменной \texttt{a}, нужно написать:
	
	\begin{lstlisting}
cout << a;
	\end{lstlisting}
	
	Выводить можно не только переменные, но и числа. Также, как и со вводом, можно выводить несколько объектов за раз. Но учитывайте, что если вывести сначала число 1, а затем число 5, то на экране будет выведено 15. Пробелы или переводы строк нужно выводить самостоятельно. Чтобы вывести пробел, выведите \texttt{' '}. Чтобы вывести перевод строки, выведите \texttt{endl} или \texttt{'\textbackslash n'}. Следует помнить, что \texttt{'\textbackslash n'} работает быстрее, чем \texttt{endl}. Пример:
	
	\begin{lstlisting}
cout << 5 << ' ' << 6 << 7 << '\n' << 8 + 3 << endl << 9;
	\end{lstlisting}
	Эта строка выведет:\\
	\texttt{
	5 67\\
	11\\
	9}
	
	Напишем программу, которая считывает 2 числа и выводит на экран их сумму:
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int a, b;
	cin >> a >> b;
	cout << a + b;
}
	\end{lstlisting}
	
	\subsection{Вычисления по модулю}
	
	В случае, когда ответ слишком большой и не помещается в тип \texttt{long long}, часто требуется вывести его по модулю $10^9+7$ или какому-либо другому. Это значит, что надо найти остаток от деления ответа на заданное число. Для решения таких задач полезно помнить следующее утверждение:
	
	\stat{Остаток суммы (разности, произведения) при делении на $m$ равен остатку суммы (разности, произведения) остатков некоторого количества чисел при делении на $m$.}
	
	\subsection{Установка и использование Code::Blocks (Windows)}
	
	Чтобы установить Code::Blocks, перейдите на страницу {\color{blue}\href{https://www.codeblocks.org/downloads/binaries/}{https://www.codeblocks.org/downloads/binaries/}}. Выберите файл \texttt{codeblocks-20.03mingw-setup.exe}. Нажмите FossHUB рядом с ним. Установите файл и запустите его. Оставляйте все настройки по умолчанию. После этого запустите Code::Blocks.
	
	\begin{enumerate}
		\item {Работать будем в проектах. Чтобы создать проект, нажмите на кнопку \texttt{Create a new project}.} 
	
		\image{cb1}{220px}
		
		\item {Выберите \texttt{Console application}.}
		
		\image{cb2}{220px}
		
		\item {Нажмите \texttt{Next}. Выберите C++, нажмите \texttt{Next}. Разберемся с следующим окном подробнее:}
		
		\image{cb3}{150px}
		
		\item {Укажите любое имя проекта (\texttt{Project title}) и папку, где проект будет создан (\texttt{Folder to create project in}). Для выбора папки нажмите на многоточие (обведено красным на картинке выше). Нажмите \texttt{Next}.}
		
		\item {Нажмите \texttt{Finish}.}
	
	\end{enumerate}
	
	Проект создан. Теперь научимся открывать файл, в котором будем писать код.
	
	\begin{enumerate}
		\item {Если у Вас открыта панель \texttt{Management} (слева), то откройте там вкладку \texttt{Projects}. Откройте все подпапки (нажав на плюс слева от названий). Нажмите дважды на \texttt{main.cpp}}
		
		\image{cb4}{150px}
		
		\item {Если панели \texttt{Management} нет, нажмите комбинацию клавиш \texttt{Shift + F2}.}
	\end{enumerate}
	
	Чтобы запустить код, нажмите клавишу \texttt{F9} или на значок \imagen{cb5}.
	
	\subsection{Структура олимпиадной задачи}
	
	Обычно олимпиадная задача состоит из нескольких частей. Разберем их все по отдельности:
	
	\begin{enumerate}
		\item{\textbf{Ограничения}. Здесь указаны ограничения по времени и памяти. Если Ваша программа будет их превышать, вы получите вердикт Превышено ограничение времени (TL или TLE --- от Time Limit Exceeded) или Превышено ограничения памяти (ML или MLE --- от Memory Limit Exceeded).}
		\item{\textbf{Имя входного/выходного файла}. Обычно здесь написано стандартный поток ввода (или \texttt{stdin}) и стандартный поток вывода (\texttt{stdout}). Если указано что-то иное, то входные данные надо читать из одного файла, а выходные данные выводить в другой файл, названия которых указаны в этой секции. О работе с файлами см. п. x.x.}
		\item{\textbf{Легенда}. Условия задач по программированию обычно содержат какую-либо интересную легенду. Например, людям дарят граф на Новый год. Но на начальном этапе, скорее всего, Вы будете встречаться с формальными условиями задач. В этой части описано общее содержание задачи.}
		\item{\textbf{Входные данные}. В этой части описывается формат входных данных --- того, что подаётся Вашей программе на вход. Также здесь описываются ограничения на размер входных данных, чтобы Вы могли подобрать алгоритм, который при таких ограничениях укладывается в отведенное время.}
		\item{\textbf{Выходные данные}. В этой части описывается формат выходных данных --- того, что должна выводить Ваша программа.}
		\item{\textbf{Система оценки}. Здесь описывается оценка задачи. Подробнее про оценку задачи см. п. x.x. При \texttt{ICPC}-формате эта секция отсутствует. В \texttt{IOI}-формате здесь приводятся ограничения на каждую из подгрупп или указывается на потестовую оценку.}
		\item{\textbf{Примеры}. Здесь приводятся один или несколько примеров входных данных и соответствующих им выходных данных. \underline{Обратите внимание}, что в тестирующей системе есть другие тесты, которые неизвестны Вам. Поэтому программа должна работать не только на тестах из условия, но и на остальных возможных тестах.}
		\item{\textbf{Замечание}. В этой секции объясняются примеры или даются иные комментарии по задаче. Часто эта секция может отсутствовать.}
	\end{enumerate}
	
	\subsection{Оценка олимпиадной задачи}
	
	Есть два наиболее популярных вида оценки задач:
	
	\begin{enumerate}
		\item{{\large ICPC}\\
			Каждая задача либо зачтена, либо не зачтена. Чтобы задача была зачтена (вердикт \texttt{OK}/\texttt{AC}/\texttt{Полное решение}, нужно, чтобы решение прошло все тесты). Скорее всего, большая часть школьных задач и задач на обучающих курсах будет именно в этом формате. Также этот формат используется в Летнем кубке по программированию 54-ой школы и на командных олимпиадах, как среди школьников, так и среди студентов. На последней на момент написания IV Внутренней олимпиаде 54-ой школы использовался этот формат.
			
			\textbf{Штраф}. Так как возможных результатов довольно мало (количество задач плюс 1), то участники, решившие одинаковое число задач, упорядочивается по штрафу. Штраф зависит от времени, прошедшего с начала соревнования до успешной сдачи задачи, и от количества неудачных посылок. \underline{В учебных задачах штраф не важен}.
		}
		
		\item{{\large IOI}\\
			В этом формате каждое решение оценивается некоторым количеством баллов (обычно от 0 до 100). Количество баллов может определяться по-разному. Ниже приведены два наиболее распространённых вида:
			\begin{enumerate}
				\item{\textbf{Оценка по подгруппам}. Задача разбита на несколько подгрупп. На каждую подгруппу, кроме, скорее всего, последней, наложены дополнительные условия, упрощающие задачу. Обычно баллы за подгруппу ставятся тогда, когда пройдены все тесты из этой подгруппы.}
				\item{\textbf{Потестовая оценка}. В задаче $n$ тестов, кроме тестов из условия, и каждый из них стоит $\dfrac{100}{n}$ баллов.}
			\end{enumerate}
			
			Этот формат используется на всех этапах Всероссийской олимпиады школьников, на многих перечневых олимпиадах и на Международной олимпиаде по информатике (\texttt{IOI}). I-III Внутренние олимпиады 54-ой школы также использовали этот формат.
		}
	\end{enumerate}

	\subsection{Вердикты тестирующей системы}

	Ниже приведены наиболее часто встречающиеся вердикты:

	\begin{table}[H]
    \centering
    \begin{tabularx}{\textwidth}{|X|X|X|X|}
        \hline
		\textbf{Полное название} & \textbf{Английское название} & \textbf{Сокращение} & \textbf{Причины} \\
		\hline
		Полное решение & OK/Accepted & OK/AC & Решение работает верно на всех тестах жюри\\
		\hline
		Неправильный ответ & Wrong answer & WA & Решение выводит неверный ответ\\
		\hline
		Превышено время исполнения & Time Limit (Exceeded) & TL/TLE & Решение работает слишком долго (из-за неподходящего алгоритма или ошибки в реализации)\\
		\hline
		Превышен лимит по памяти & Memory Limit (Exceeded) & ML/MLE & Решение выделяет слишком много памяти\\
		\hline
		Ошибка исполнения & Runtime Error & RE & Решение исполняется с ошибкой\\
		\hline
		Ошибка компиляции & Compilation Error & CE & Решение не компилируется\\
		\hline
		Ошибка представления & Presentation Error & PE & Формат вывода программы не соответствует выходным данным. В некоторых системах отображается как WA.\\
		\hline
    \end{tabularx}
	\end{table}

	Далее приведены специфичные вердикты:

	\begin{table}[H]
    \centering
    \begin{tabularx}{\textwidth}{|X|X|X|X|}
		\hline
		\textbf{Полное название} & \textbf{Английское название} & \textbf{Сокращение} & \textbf{Причины} \\
		\hline
		Нарушение стиля оформления программ & Style Violation & SV & Пробелы в коде стоят не там, где надо, отступы не соответствуют требуемым и т.д.\\
		\hline
		Ожидает подтверждения & Pending Review & PR & Посылка прошла тесты, но ожидает ручного подтверждения\\
		\hline
		Отклонено & Rejected & RJ & Преподаватель признал попытку неверной\\
		\hline
		Превышен лимит бездействия/Решение <<зависло>> & Idleness Limit (Exceeded) & IL/ILE & Этот вердикт предназначен для интерактивных задач (подробнее см. п. x.x), когда программа слишком долго не взаимодействует с интерактором. Обычно происходит, если в решении не сбрасывается буфер потока вывода.\\
		\hline
	\end{tabularx}
	\end{table}
	
	\subsection{Числа с плавающей точкой (Дробные числа)}
	
	До этого мы работали только с целыми числами. Теперь познакомимся с дробными числами. Из-за особенностей их хранения в памяти, вычисления с ними не точны, поэтому лучше использовать целые числа, если есть такая возможность.
	
	Для хранения в памяти дробных чисел существуют типы \texttt{float}, \texttt{double}, \texttt{long double}. Каждый из них умеет хранить числа точнее, чем предыдущий. Не рекомендуется использовать тип \texttt{float} из-за его маленькой точности. Арифметические операции осуществляются с ними так же, как и с целыми. Но оператор деления делит не нацело, а <<как в математике>> $\left(\dfrac{5.0}{2.0}=2.5\right)$. Для выполнения деления без округления хотя бы один из операндов должен быть числом с плавающей точкой. Для приведения целого числа к типу \texttt{double} его можно умножить на \texttt{1.0}, для приведения к типу \texttt{long double} --- на \texttt{1.0l}. Суффикс \texttt{l} (латинская строчная L) показывает, что число имеет тип \texttt{long double}.
	
	Обратите внимание, что десятичным разделителем является точка.
	
	Еще одна возможная форма записи чисел с плавающей точкой --- научная. Например, \texttt{2.4e6} означает то же, что и $2.4 \cdot 10 ^ 6$. Для записи больших целых чисел тоже используется такой формат. Например, можно часто встретить
	
	\begin{lstlisting}
const int INF = 2e9;
	\end{lstlisting}
	
	или 
	
	\begin{lstlisting}
const int MOD = 1e9 + 7;
	\end{lstlisting}
	
	Но на самом деле, C++ создает дробное число, а затем преобразует его к целому. (Такая константа \texttt{INF} используется для обозначения числа, которое больше любого другого числа, при работе в типе \texttt{int}. Константа \texttt{MOD} используется для вычислений по модулю. (см. п. x.x))
	
	Есть особенность, связанная с выводом чисел с плавающей точкой. Познакомимся с ней на примере. Запустим следующий код:
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	long double a = 1001;
	cout << a * a * a << '\n';
}
	\end{lstlisting}
	
	Этот код считает $1001^3$ в дробных числах. Мы ожидаем получить ответ $1003003001$, но после запуска увидим $1.003e+09$. Ответ посчитан верно, но с очень низкой точностью. В задачах обычно указана точность ответа, но лучше всегда выводить максимальное возможное количество знаков после запятой, если вывод лишних знаков не противоречит условию. Чтобы управлять точностью выводимых чисел, допишите после \texttt{\#include <iostream>} строку \texttt{\#include <iomanip>}. В следующей строке после \texttt{int main() \{} напишите \texttt{cout << fixed << setprecision(100);}. Этот код всегда будет выводить 100 цифр после запятой. Если не требуется выводить нули после запятой, можно опустить \texttt{fixed <<}.
	
	Тогда наш исправленный код будет выглядеть так:
	
	\begin{lstlisting}
#include <iostream>
#include <iomanip>

using namespace std;

int main() {
	cout << fixed << setprecision(100);
	long double a = 1001;
	cout << a * a * a << '\n';
}
	\end{lstlisting}

	\subsection{Расширенная математика}

	Мы научились выполнять арифметические операции. Но часто требуются и другие математические операции: корень, тригонометрические функции, логарифм. Чтобы использовать их, требуется в начале кода написать после строки \texttt{\#include <iostream>} строку \texttt{\#include <cmath>}.

	Ниже приведена таблица функций:

	\tabularII{
		\hline
		\textbf{Название в C++} & \textbf{Описание}\\
		\hline
		sqrt & Квадратный корень\\
		\hline
		cbrt & Кубический корень\\
		\hline
		pow & Возведение в степень\\
		\hline
		abs & Модуль\\
		\hline
		log & Натуральный логарифм\\
		\hline
		log10 & Десятичный логарифм\\
		\hline
		log2 & Двоичный логарифм\\
		\hline
		sin, cos, tan & Тригонометрические функции\\
		\hline
		asin, acos, atan & Обратные тригонометрические функции\\
		\hline
		floor, ceil, round & Округление (вниз, вверх, к ближайшему)\\
		\hline
	}

	\important{Все тригонометрические функции работают в радианах ($1\ \text{радиан} = \frac{\pi}{180}^\circ$).}

	\important{Возведение в степень работает только в дробных числах, поэтому в случае целых чисел надёжнее реализовать руками.}
	
	\section{Ветвление}
	
	\subsection{Тип данных \texttt{bool}. Логические условия}
	
	На данный момент нам известно два типа данных --- \texttt{int} и \texttt{long long}. Познакомимся ещё с одним типом данных --- \texttt{bool}. Тип данных \texttt{bool} хранит одно из двух возможных значений: \texttt{Истина (да)} или \texttt{Ложь (нет)}. Например, выражение $5>4$ равносильно \texttt{Истине}, а $5>5$ равносильно \texttt{Лжи}. В C++ \texttt{Истина} обозначается \texttt{true}, а \texttt{Ложь} --- \texttt{false}. Вы можете создать переменную типа \texttt{bool} так же, как и переменную других известных Вам типов:
	
	\begin{lstlisting}
bool a;
	\end{lstlisting}
	
	или
	
	\begin{lstlisting}
bool a = true;
	\end{lstlisting}
	
	Также можно выводить переменную типа \texttt{bool}. При выводе значения \texttt{true} будет напечатана единица, при выводе \texttt{false}\;--- ноль. При вводе \texttt{bool} происходит считывание числа. Если оно равно $0$, то результатом будет \texttt{false}; иначе результатом будет \texttt{true}.
	
	В C++ есть возможность сравнивать числа с помощью операторов $>$, $<$, $\ge$, $\le$, $=$, $\ne$, но форма их записи отличается. В таблице ниже приведено обозначение этих операторов в C++:
	
	\tabularII{
		\hline
		\textbf{Математика} & \textbf{C++}\\
		\hline
		$>$ & \texttt{>}\\
		\hline
		$<$ & \texttt{<}\\
		\hline
		$\ge$ & \texttt{>=}\\
		\hline
		$\le$ & \texttt{<=}\\
		\hline
		$=$ & \texttt{==}\\
		\hline
		$\ne$ & \texttt{!=}\\
		\hline
	}
	
	Результат сравнения имеет тип \texttt{bool}. Например, после выполнения кода
	
	\begin{lstlisting}
bool a = 5 > 3;
	\end{lstlisting}
	
	в переменной \texttt{a} будет храниться значение \texttt{true}.
	
	\subsection{Операторы над типом \texttt{bool}}
	
	Тип \texttt{bool} кажется довольно странным, но позже мы увидим, что он часто оказывается полезен. Пока познакомимся с операторами для работы с этим типом. В таблице ниже приведены названия и обозначения в C++ каждого из операторов.
	
	\tabularII{
		\hline
		\textbf{Оператор в C++} & \textbf{Название}\\
		\hline
		\&\& & логическое И\\
		\hline
		$\vert\vert$ & логическое ИЛИ\\
		\hline
		== & равенство\\
		\hline
		!= & неравенство\\
		\hline
	}
	
	Последние два оператора работают так же, как и с остальными типами данных. Остановимся на первых двух подробнее.
	
	Результат логического И для двух операндов истинен тогда и только тогда, когда оба операнда истинны. Таблица истинности для этого оператора:
	
	\tabularIII{
		\hline
		\textbf{$A$} & \textbf{$B$} & \textbf{$A\&\&B$}\\
		\hline
		\texttt{false} & \texttt{false} & \texttt{false}\\
		\hline
		\texttt{false} & \texttt{true} & \texttt{false}\\
		\hline
		\texttt{true} & \texttt{false} & \texttt{false}\\
		\hline
		\texttt{true} & \texttt{true} & \texttt{true}\\
		\hline
	}
	
	Результат логического ИЛИ истинен тогда и только тогда, когда хотя бы один из двух операндов истинен. Таблица истинности для него:
	
	\tabularIII{
		\hline
		\textbf{$A$} & \textbf{$B$} & \textbf{$A\vert\vert B$}\\
		\hline
		\texttt{false} & \texttt{false} & \texttt{false}\\
		\hline
		\texttt{false} & \texttt{true} & \texttt{true}\\
		\hline
		\texttt{true} & \texttt{false} & \texttt{true}\\
		\hline
		\texttt{true} & \texttt{true} & \texttt{true}\\
		\hline
	}
	
	Кроме того, для типа \texttt{bool} определён унарный оператор отрицания, обозначаемый \texttt{!}. Он меняет значение, к которому применяется, на противоположное. Таким образом, его таблица истинности выглядит так:
	
	\tabularII{
		\hline
		\textbf{$A$} & \textbf{$!A$}\\
		\hline
		\texttt{false} & \texttt{true}\\
		\hline
		\texttt{true} & \texttt{false}\\
		\hline
	}
	
	\style{Напоминаем, что бинарные операторы (в т.ч. логические) отделяются от своих операндов пробелами. Между унарным оператором и его операндом пробел не ставится.}
	
	\note{Если логическим операторам передавать числа как операнды, то они будут преобразованы к типу \texttt{bool} по следующему правилу: $0$ преобразуется в \texttt{false}, все остальные числа --- в \texttt{true}.}
	
	\subsection{Неполное ветвление. Ключевое слово \texttt{if}}
	
	Мы научились сравнивать числа. Но сейчас наша программа выполняется строчка за строчкой, мы пока не можем выполнять различные действия в зависимости от некоторых условий. Но такая возможность есть, и в этом пункте мы познакомимся с ней. Фраза <<Если выполнено условие A, то сделай B>> на C++ будет записана так:
	
	\begin{lstlisting}
if (A) {
	B;
}
	\end{lstlisting}
	
	После выполнения этого блока кода, будет выполнена следующая после закрывающей фигурной скобки строчка.
	
	<<Место B>> называется \textit{телом} условной конструкции, A --- \textit{условием}.
	
	Тело может состоять из нескольких инструкций.
	
	Напишем код, который выполняет следующий следующий алгоритм:
	
	\begin{enumerate}
		\item{Считать число.}
		\item{Если число больше 5, вычесть из него 1.}
		\item{Вывести число.}
	\end{enumerate}
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int x;
	cin >> x;
	if (x > 5) {
		x = x - 1;
	}
	cout << x << '\n';
}
	\end{lstlisting}
	
	\style{Отступ в теле условной конструкции должен быть на один tab (4 пробела) больше, чем отступ вне её.}
	
	Условие может состоять из нескольких логических выражений, объединённых логическими операторами, которые мы изучили ранее. Решим следующую задачу:
	
	\task{Вводится целое число $x$. Если $5\le x\le 10$, то выведите $1$, иначе не выводите ничего.}
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int x;
	cin >> x;
	if (x >= 5 && x <= 10) {
		cout << 1;
	}
}
	\end{lstlisting}
	
	\important{Запись \texttt{5 <= x <= 10} в C++ не равносильна математическому двойному неравенству $5\le x\le 10$, в отличие от других языков (например, Python), которые могут допускать такую запись. Корректно писать так, как в приведённом выше примере.}
	
	\subsection{Полное ветвление. Ключевое слово \texttt{else}}
	
	Ключевое слово \texttt{else} может идти только после условной конструкции. Синтаксис при его использовании таков:
	
	\begin{lstlisting}
if (A) {
	B;
} else {
	C;
}
	\end{lstlisting}
	
	Блоки \texttt{A} и \texttt{B} были разобраны в прошлом пункте. Инструкции блока \texttt{C} выполняются только в том случае, когда не выполнилось условие \texttt{A}. В блоке \texttt{C}, как и в блоке \texttt{B}, может быть несколько инструкций. Например, в прошлом пункте мы решали задачу о принадлежности числа отрезку $[5; 10]$. Если число не принадлежало отрезку, то мы ничего не выводили. Давайте в таком случае выведем $0$:
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int x;
	cin >> x;
	if (x >= 5 && x <= 10) {
		cout << 1;
	} else {
		cout << 0;
	}
}
	\end{lstlisting}
	
	\subsection{Использование \texttt{else-if}}
	
	Мы научились делать что-либо, если какое-то условие выполнено, и научились выбирать из двух вариантов действий нужный, исходя из истинности условия. Теперь рассмотрим, что делать, если вариантов действий больше двух. Например, решим такую задачу:
	
	\task{Требуется определить возрастную категорию человека по его возрасту в годах $x$. Если человеку ещё нет $7$ лет, отнесём его к категории $0$ (дошкольники), если уже есть $7$, но ещё нет $18$, --- к категории $1$ (школьники), если есть $18$ --- к категории $2$ (взрослые).}
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int x;
	cin >> x;
	if (x < 7) {
		cout << 0;
	} else if (x < 18) {
		cout << 1;
	} else {
		cout << 2;
	}
}
	\end{lstlisting}
	
	Когда C++ видит такую конструкцию, он последовательно проверяет условия. Когда он находит истинное, он выполняет тело после этого условие, а затем пропускает все остальные. Если ни одно из условий не выполнилось, выполняется тело \texttt{else}. Именно поэтому во втором условии нет проверки $x\ge 7$, так как, если это условие было бы не выполнено, то выполнился бы первый блок.
	
	Конструкций \texttt{else-if} может быть много. Например,
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int x;
	cin >> x;
	if (x < 7) {
		cout << 0;
	} else if (x < 18) {
		cout << 1;
	} else if (x < 35) {
		cout << 2;
	} else {
		cout << 3;
	}
}
	\end{lstlisting}
	
	\subsection{Вывод текста на экран}
	
	Часто в задачах, где надо проверить какие-либо условия, требуется вывести <<YES>> или <<NO>>. Чтобы вывести текст, надо записать его в кавычках (\texttt{"}), чтобы C++ не думал, что слова в нём --- названия переменных. Например, чтобы вывести <<YES>> (без кавычек), нужно написать:
	
	\begin{lstlisting}
cout << "YES";
	\end{lstlisting}
	
	\section{Циклы. Цикл с предусловием. Цикл <<$n$ раз>>. Цикл с постусловием. Вложенные циклы.}
	
	Наш код уже может выполняться по-разному в зависимости от разных условий. Теперь рассмотрим способы <<зациклить>> наш алгоритм --- повторять его некоторое количество раз. Перед этим познакомимся с составными арифметическими операторами, которые зачастую удобны при написании циклов.
	
	\subsection{Составные арифметические операции}
	
	Мы уже знаем, что для увеличения переменной x на 1 можно написать следующий код:
	
	\begin{lstlisting}
x = x + 1;
	\end{lstlisting}
	
	Увеличение переменной на 1 часто используется в циклах, поэтому для этой операции есть сокращённая запись:
	
	\begin{lstlisting}
++x;
	\end{lstlisting}
	
	\texttt{++} --- это оператор \textit{инкремента}. Точнее, приведённая выше запись --- это \textit{префиксный инкремент}. Также существует \textit{постфиксный инкремент}:
	
	\begin{lstlisting}
x++;
	\end{lstlisting}
	
	\note{Разница между префиксным и постфиксным инкрементом проявляется, если результат выполнения присвоить другой переменной. При использовании префиксного инкремента, значение новой переменной будет равно новому значению инкрементируемой, а при использовании постфиксного инкремента --- старому. Кроме того, префиксный инкремент работает быстрее постфиксного, хотя и несильно.}
	
	Существуют и другие составные операторы. Они приведены в таблице ниже:
	
	\tabularII{
		\hline
		\textbf{Сокращённая запись} & \textbf{Полная запись}\\
		\hline
		\texttt{a += b;} & \texttt{a = a + b;}\\
		\hline
		\texttt{a -= b;} & \texttt{a = a - b;}\\
		\hline
		\texttt{a *= b;} & \texttt{a = a * b;}\\
		\hline
		\texttt{a /= b;} & \texttt{a = a / b;}\\
		\hline
		\texttt{a \%= b;} & \texttt{a = a \% b;}\\
		\hline
	}
	
	\subsection{Цикл с предусловием (\texttt{while})}
	
	Рассмотрим самый простой из циклов --- цикл с предусловием (цикл \texttt{while} --- от англ. <<пока>>). Он имеет такой же синтаксис, как и \texttt{if} (в круглых скобках условие $A$, затем в фигурных скобках тело цикла $B$). Когда C++ выполняет этот блок кода, он поступает так:
	
	\begin{enumerate}
		\item{Если $A$ выполнено, сделать $B$.}
		\item{Если $A$ выполнено, сделать $B$.}
		\item{Если $A$ выполнено, сделать $B$.}
		
		\dots
	\end{enumerate}
	
	Как только условие перестаёт быть выполнено, C++ переходит к коду после цикла.
	
	Следующий код выводит числа от 1 до 5:
	
	\begin{lstlisting}
int i = 1;
while (i <= 5) {
	cout << i << endl;
	i++;
}
	\end{lstlisting}
	
	\style{Тело циклов (как этого, так и остальных) пишется с отступом на 1 tab (4 пробела) больше, чем у кода вне цикла.}
	
	\style{Наиболее распространённые названия переменных для счётчиков циклов --- $i$, $j$, $k$. От них ожидается такое предназначение. А от переменных $a$, $x$, $m$ --- не ожидается.}
	
	Один проход по телу цикла называется \textit{итерацией}.
	
	\subsection{Цикл <<$n$ раз>> (\texttt{for})}
	
	Рассмотрим тот же код, что и в прошлом примере. Оказывается, такие конструкции --- перебор чисел в каком-то диапазоне с фиксированным шагом --- встречаются довольно часто. Но при написании такой конструкции легко ошибиться, например, пропустить \texttt{i++}. Поэтому в языке C++ существует другой цикл, упрощающий такую конструкцию. Этот цикл называется \textit{циклом \texttt{for}}. Можно предположить, что это связано с его языковым аналогом <<\underline{для} каждого числа от ... до ... с шагом ... выполнить ...>>. Познакомимся с его синтаксисом:
	
	\begin{lstlisting}
for (A; B; C) {
	D;
}
	\end{lstlisting}
	
	$A$ содержит инструкцию, выполняемую до цикла один раз. Чаще всего, это инициализация счётчика.
	
	$B$ содержит условие, которое проверяется перед каждой итерацией. Если условие не выполняется, цикл завершается.
	
	$C$ содержит инструкцию, выполняемую после каждой итерации. Обычно это изменение счётчиков.
	
	$D$ --- тело цикла, то есть то, что выполняется на каждой итерации.
	
	Рассмотрим задачу:
	
	\task{Вводится число $n\ (1\le n\le 10^5)$. Выведите все натуральные числа от $1$ до $n$ (включительно).}
	
	Мы уже умеем решать эту задачу циклом \texttt{while}. Теперь решим её циклом \texttt{for}:
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cout << i << endl;
	}
}
	\end{lstlisting}
	
	Перед циклом мы создаём переменную $i$, изначально равную единице. Условие выполнения нашего цикла --- $i \le n$. После каждой итерации мы увеличиваем $i$ на 1. На каждой итерации мы выводим $i$.
	
	\note{Цикл \texttt{for} может быть заменён на \texttt{while} (выше текстом описано, как это сделать). Но это не является хорошим тоном, так как понижает читабельность кода.}
	
	\note{Некоторые части могут опускаться, например, ниже приведён корректный код:}
	
	\begin{lstlisting}
int i = 1;
for (; i <= 5; i++) {
	cout << i << endl;
}
	\end{lstlisting}
	
	\subsection{Цикл с постусловием (\texttt{do-while})}
	
	Циклы \texttt{while} и \texttt{for} проверяют условие до выполнения цикла. Из этого следует, что если условие изначально ложно, то цикл не будет выполнен ни разу. Иногда это неудобно. Для этого создан цикл с постусловием. В отличие от цикла \texttt{while}, он выполняет следующее:
	
	\begin{enumerate}
		\item {Выполнить $B$.}
		\item {Если $A$, выполнить $B$.}
		\item {Если $A$, выполнить $B$.}
		\item {Если $A$, выполнить $B$.}
	\end{enumerate}
	
	...
	
	Таким образом, тело цикла \texttt{do-while} всегда выполняется хотя бы один раз.
	
	Познакомимся с синтаксисом этого цикла в C++:
	
	\begin{lstlisting}
do {
	B;
} while (A);
	\end{lstlisting}
	
	Условие проверяется после выполнения тела и записывается после него. Обратите внимание на \texttt{;} после условия.
	
	\section{Массивы}
	
	\subsection{Одномерные статические массивы}
	
	Часто в задачах возникает необходимость хранить некоторую последовательность значений довольно большой или заранее неизвестной длины. В таком случае применяются \textit{массивы}. Массив --- это упорядоченный набор значений одного типа. В этой главе мы познакомимся со статическими массивами. Динамические массивы будут разобраны позже.
	
	\note{Статические массивы --- <<наследие>> языка Си, предшественника C++.}
	
	Чтобы создать массив используется следующий синтаксис:
	
	\begin{lstlisting}
type name[size];
	\end{lstlisting}
	
	\texttt{type} --- это тип значений в массиве, \texttt{name} --- название переменной (имя массива), \texttt{size} --- размер массива, то есть количество значений, которое будет в нём храниться.
	
	Кроме того, элементам массива можно сразу присвоить значения:
	
	\begin{lstlisting}
int arr[5] = {1, 2, 3, 4, 5};
	\end{lstlisting}
	
	\underline{Обратите внимание}, что элементы массива перечисляются в фигурных скобках, в отличие от многих других языков программирования (Python, JavaScript).

	Чтобы заполнить массив нулями, можно использовать такой синтаксис:

	\begin{lstlisting}
int arr[5] = {0};
	\end{lstlisting}

	\important{Чтобы заполнить массив числами, отличными от нуля, нужно использовать цикл \texttt{for}.}
	
	Чтобы обращаться к элементам массива, используются квадратные скобки. Например, \texttt{arr[1]}.
	
	\important{Индексация (то есть нумерация элементов) массива начинается с \textbf{нуля}, а не с единицы. Поэтому если использовать приведённый выше массив, то \texttt{arr[0]} будет равно $1$, а \texttt{arr[1]} --- 2.}
	
	Массивы часто используется вместе с циклами. Например решим следующую задачу:
	
	\task{Дано число $n$, на следующей строке последовательность из $n$ чисел через пробел. Выведите эту последовательность в обратном порядке.}
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int n;
	cin >> n;
	int a[n];
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	for (int i = n - 1; i >= 0; i--) {
		cout << a[i] << ' ';
	}
}
	\end{lstlisting}
	
	\note{При работе со статическими массивами, их размер, согласно стандарту, требуется делать известным заранее (например, $10^5$). Несмотря на это, компилятор GCC допускает использование массивов так, как в приведённом выше примере.}

	Написанный по стандарту код будет выглядеть так:

	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	const int ARRAY_SIZE = 1e5;
	int n;
	cin >> n;
	int a[ARRAY_SIZE];
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	for (int i = n - 1; i >= 0; i--) {
		cout << a[i] << ' ';
	}
}
	\end{lstlisting}

	\style{В случае использования констант, их следует объявлять как константы (так, как в приведённом выше примере).}

	\note{Выделение лишней памяти негативно сказывается на производительности. Но в задачах это не существенно, так как время и память оцениваются по наибольшим показателям среди всех тестов, а среди тестов обязательно встретится тест с максимальными ограничениями. Позже мы познакомимся с динамическим массивом (\texttt{vector}), который является более гибким.}
	
	\subsection{Двумерные массивы}
	
	Двумерные массивы служат для представления таблиц. Чтобы создать массив размера $n\times m$ требуется использовать \texttt{type name[n][m]} --- аналогично одномерным.

	Решим следующую задачу:

	\task{Даны числа $n$ и $m$ и массив целых чисел размера $n\times m$. Посчитайте сумму в каждой строке и в каждом столбце.}

	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int n, m;
	cin >> n >> m;
	int arr[n][m];
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			cin >> arr[i][j];
		}
	}
	int sum_row[n];
	for (int i = 0; i < n; i++) {
		sum_row[i] = 0;
		for (int j = 0; j < m; j++) {
			sum_row[i] += arr[i][j];
		}
	}
	int sum_col[m];
	for (int i = 0; i < m; i++) {
		sum_col[i] = 0;
		for (int j = 0; j < n; j++) {
			sum_col[i] += arr[j][i];
		}
	}
	for (int i = 0; i < n; i++) {
		cout << sum_row[i] << ' ';
	}
	cout << '\n';
	for (int i = 0; i < m; i++) {
		cout << sum_col[i] << ' ';
	}
	cout << '\n';
}
	\end{lstlisting}
	
	\section{Символы. Строки.}
	
	\subsection{Символы}
	
	Раньше мы работали только с числами и массивами чисел. Теперь научимся работать с текстом. Познакомимся с новым типом данных C++ --- символ (\texttt{char}). По умолчанию C++ работает с символами по таблице ASCII (American Standard Code for Information Interchange) (читается [аски]), которые содержат только латинские буквы, цифры, знаки пунктуации и некоторые служебные символы (перевод строки, возврат каретки, конец файла и т.д.). В таблице ASCII каждому символу сопоставлен номер от $0$ до $127$. Таким образом, номер символа можно хранить в 7 битах, но, из-за особенностей устройства памяти в компьютере, тип \texttt{char} занимает 1 байт (8 бит). Ниже приведена таблица ASCII:
	
	\begin{center}
		\image{ascii-table}{220px}
	\end{center}
	
	Символы до \textnumero$31$ все являются служебными.
	
	Значения этого типа пишутся в одинарных кавычках, например,
	
	\begin{lstlisting}
char c = 'x';
	\end{lstlisting}
	
	Выведем $c$ на экран. На экране мы увидим символ \texttt{x}. Теперь рассмотрим следующий код:
	
	\begin{lstlisting}
char c = 'x';
int a = c;
cout << a;
	\end{lstlisting}
	
	На экране мы увидим число $120$ --- номер символа \texttt{x}.
	
	\subsubsection{Арифметические операции с символами}
	
	Благодаря тому, что символам сопоставлены числа, мы можем работать с ними, как с числами. Рассмотрим следующий пример:
	
	\task{Дан символ, являющийся строчной буквой латинского алфавита. Определить его номер в алфавите (считая, что букве \texttt{a} соответствует номер 1).}
	
	Вычтем из данного нам символа символ \texttt{a}. Тогда мы узнаем номер символа в $0$-индексации. Добавим 1, чтобы получить его в $1$-индексации.
	
	\begin{lstlisting}
char c;
cin >> c;
cout << c - 'a' + 1;
	\end{lstlisting}
	
	Другой пример:
	
	\task{Дано число $x$. Выведите $x$-ю строчную букву латинского алфавита.}
	
	Теперь нам нужно решить задачу, обратную предыдущей. Напишем такой код:
	
	\begin{lstlisting}
int x;
cin >> x;
cout << 'a' + (x - 1);
	\end{lstlisting}
	
	Запустим его. Введём, например, $5$. На экране мы увидим $101$. Это связано с тем, что результат арифметический действий над символами вычисляется в типе \texttt{int}. Чтобы исправить это, изменим код так:
	
	\begin{lstlisting}
int x;
cin >> x;
cout << (char)('a' + (x - 1));
	\end{lstlisting}
	
	Теперь код, как и должно быть, выводит \texttt{e}.
	
	\exercise{Вводится символ, являющийся цифрой. Считайте его \underline{как символ}, а затем преобразуйте к соответствующему числу (в тип \texttt{int}).}
	
	\subsubsection{Логические операторы}
	
	С символами определены и операторы сравнения ($>$, $<$ и т.д.). Символы сравниваются в порядке номеров в таблице ASCII. Наиболее часто пригождается проверка, является ли символ буквой (строчной буквой, заглавной буквой, цифрой и т.д.).
	
	Так как строчные буквы (как и заглавные буквы и цифры) идут в таблице ASCII последовательно, для этого достаточно сравнить символы. Например, так:
	
	\begin{lstlisting}
char c;
cin >> c;
if ('A' <= c && c <= 'Z') {
	cout << "YES";
} else {
	cout << "NO";
}
	\end{lstlisting}

	\subsection{Строки}

	\textit{Строкой} в программировании называется любая последовательность символов. Для хранения строк используется тип \texttt{string}. Для него определён ввод и вывод (через \texttt{>>} и \texttt{<<} соответственно). Для обращения к номерам символов используется такой же синтаксис, как и у массивов, --- квадратные скобки.

	\important{Нумерация символов в строке начинается с $0$.}

	Кроме того, для скобок определен оператор \texttt{+}, который выполняет \textit{конкатенацию} строк, то есть их <<склеивание>>. Кроме того, для строк определён \textit{метод} \texttt{substr}, который позволяет получить \textit{подстроку} (то есть непрерывный участок исходной строки). Познакомимся с методом \texttt{substr} на примере:

	\begin{lstlisting}
string s;

cin >> s;
cout << s.substr(2, 3);
	\end{lstlisting}

	В круглых скобках через запятую указываются два числа: номер первого символа в подстроке и длина подстроки.
	
	\section{Процедуры. Функции. Рекурсия.}

	Циклы помогли нам избежать повторов аналогичного кода. Отсутствие повторов --- это хорошо, потому что:
	
	\begin{enumerate}
		\item {Код меньше.}
		\item {Если есть ошибка, её надо исправить только в одном месте.}
	\end{enumerate}
	
	Функции --- это ещё один способ избавиться от повторов.

	Перед тем, как говорить о функциях, поговорим о назначении команд \texttt{\#include} и \texttt{using}.

	\subsection{Развеевание магии}

	Команда \texttt{\#include} \textit{подключает библиотеки}, то есть позволяет использовать код, написанный разработчиками языка. Название библиотек указывается в треугольных кавычках. Приведём наиболее популярные из встроенных библиотек:

	\begin{tabularx}{\textwidth}{|X|X|}
		\hline
		\textbf{Название} & \textbf{Описание}\\
		\hline
		\texttt{iostream} & Работа с вводом-выводом\\
		\hline
		\texttt{iomanip} & Настройка ввода-вывода\\
		\hline
		\texttt{vector} & Векторы (динамические массивы) --- будут рассмотрены позже\\
		\hline
		\texttt{algorithm} & Алгоритмы (сортировка, бинарный поиск). Вы познакомитесь с ней в 9 классе\\
		\hline
	\end{tabularx}
	
	\subsection{Процедуры}
	
	Разберём несколько задач, чтобы понять, что такое процедура.
	
	\task{Три раза повторите следующее: считайте строку $s$ и выведите <<\texttt{Hello, }>>, а затем строку $s$.}
	
	Выделим повторяющуюся часть кода. Здесь это чтение строки $s$ и вывод приветствия.
	
	\begin{lstlisting}
#include <iostream>
#include <string>

using namespace std;

void hello() {
	string s;
	cin >> s;
	cout << "Hello, " << s << '\n';
}

int main() {
	for (int i = 0; i < 3; i++) {
		hello();
	}
}
	\end{lstlisting}
	
	Мы определили процедуру \texttt{hello}. Внутри фигурных скобок написано то, что она делает. Чтобы \textit{вызвать} (выполнить) её, нужно написать её имя (в данном случае, \texttt{hello}), а затем круглые скобки.
	
	\task{Дано число $n$. Вывести $n$ строк, в $i$-й строке вывести $i$ символов <<*>>.}
	
	Попробуем найти в задаче повторяющийся алгоритм. В данном случае, это вывод некоторого количества звёздочек. Отличается лишь их количество. В прошлом примере алгоритмы полностью совпадали. Теперь у алгоритма появился некоторый параметр. Поэтому мы можем создать \textit{процедуру}, которая будет \textit{принимать} параметр $x$ и печатать $x$ звёздочек. В основном коде мы $n$ раз \textit{вызовем} (выполним) эту процедуру для каждого $x$ от $1$ до $n$. В коде это будет выглядеть так:
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

void printStars(int x) {
	for (int i = 0; i < x; i++) {
		cout << '*';
	}
	cout << '\n';
}

int main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		printStars(i);
	}
}
	\end{lstlisting}

	\note{Безусловно, примеры, приведённые в этой главе довольно надуманы. Несмотря на это, функции являются очень важными при написании крупного кода. Кроме того, скоро мы познакомимся с рекурсией, использование которой часто помогает написать более простой код.}

	\note{Название функций должно удовлетворять тем же требованиям, что и имена переменных.}

	\subsection{Функции}

	Процедуры умеют совершать аналогичные действия для разных параметров. Но часто требуется, чтобы функция, как в математике, <<выдавала>> (\textit{возвращала}) некоторый результат.

	Функции определяются так:

	\begin{lstlisting}
ReturnType name(Type1 arg1, Type2 arg2, ... Typen argn) {
	body;
}
	\end{lstlisting}

	\texttt{ReturnType} --- тип возвращаемого значения, \texttt{name} --- имя функции, \texttt{Typei} --- тип $i$-го элемента, \texttt{argi} --- имя $i$-го элемента.

	Например, пусть нам нужна функция, которая вычисляет длину гипотенузы по двум катетам. Тогда она принимает два вещественных числа, длины катетов, и возвращает одно вещественное число --- длину гипотенузы. Эта функция будет выглядеть так:

	\begin{lstlisting}
long double hyp(long double a, long double b) {
	return sqrt(a * a + b * b);
}
	\end{lstlisting}

	Обратите внимание на ключевое слово \texttt{return}. После него следует то значение, которое возвращает функция.

	Кроме того, следует заметить, что \texttt{sqrt} --- тоже функция, но она определена не нами, а авторами библиотеки \texttt{cmath}.

	\subsection{О \texttt{main}}

	Теперь посмотрим на \texttt{main}. По синтаксису это функция, которая возвращает целое число, но ничего не принимает. Обратите внимание, что нами эта функция нигде явно не вызывается. Но почему же она возвращает целое число? И почему мы не используем \texttt{return}?

	На самом деле, функция \texttt{main} возвращает то значение, которое возвращает программа. Обычно мы нигде не сталкиваемся с возвращаемым значением программ, но он используется, чтобы указать, завершилась ли программа без ошибок или с какой ошибкой. Если программа завершилась без ошибок, то возвращаемое значение должно быть равно $0$. Иначе оно должно быть отлично от $0$.

	Большинство наиболее используемых компиляторов сами добавляют \texttt{return 0;} в конец функции \texttt{main}.

	\important{Если функция \texttt{main} будет возвращать значение, отличное от $0$, программа в тестирующей системе получит вердикт \texttt{Ошибка исполнения}.}

	\subsection{Рекурсия}

	Думаю, из математики вам известен метод математической индукции. Например, чтобы доказать, что $1+2+\dots+n=\dfrac{n(n+1)}{2}$, можно сделать так:

	\textbf{База: $n=1$}. Тогда $\dfrac{n(n+1)}{2}=\dfrac{1\cdot 2}{2}=1$ --- верно.

	\textbf{Переход:} Пусть верно для $n=k$, докажем для $n=k+1$:

	$$1+2+\dots+(k+1) = (1+2+\dots+k) + (k+1) = \dfrac{k(k+1)}{2} + (k+1) = \dfrac{k(k+1) + 2(k+1)}{2} = \dfrac{(k+1)(k+2)}{2}$$.

	Возможно, вы встречались и с рекуррентными соотношениями --- последовательностями, в которых каждый следующий элемент определяется через предыдущие. Например, такой последовательностью являются числа Фибоначчи:

	$$F_1=F_2=1, F_n = F_{n-2}+F_{n-1}\ (n \ge 3)$$

	Попробуем реализовать функцию, которая вычисляет $n$-ое число Фибоначчи.

	\begin{lstlisting}
int fib(int n) {
	if (n == 1 || n == 2) {
		return 1;
	}
	return fib(n - 1) + fib(n - 2);
}
	\end{lstlisting}
	
	В этой функции описано на языке C++ то, что было описано раньше словами.
	
	\note{Данный код крайне не эффективен, так как мы многократно вычисляем значение для одного и того же числа}

	\section{Дополнительные темы}
	
	\subsection{Что происходит, когда мы запускаем код?}
	
	У C++ есть важное отличие от, например, Python или Java. C++ --- \textit{компилируемый} язык программирования, в отличие от Python, \textit{интерпретируемого} языка программирования. Программа на C++ сначала переводится в \textit{байт-код} (например, \texttt{.exe}-файл), а затем байт-код выполняется операционной системой. Процесс перевода называется \textit{компиляцией}, а программа, его осуществляющая --- \textit{компилятором}. Байт-код --- это некоторая последовательность примитивных инструкций, которая отличается от \textit{машинного кода} тем, что она зависит только от операционной системы, но не от процессора. В этой универсальности и состоит преимущество байт-кода над машинным кодом.
	
	Программа на Python выполняется сразу из исходного кода, что значительно замедляет этот процесс.
	
	С Java все ещё более интересно. Она компилируется в свой байт-код, который не зависит от ОС, а затем этот байт-код выполняется в виртуальной машине (JVM).
	
	\subsection{Файловый ввод-вывод}
	
	В некоторых задачах требуется читать входные данные из одного файла, а записывать в другой. Насколько мне известно, это было популярно в середине 2010-х годов. Познакомимся с двумя способами работать с файлами.
	
	\subsubsection{\texttt{freopen}}
	
	Если вам нужно сделать так, чтобы потоки \texttt{cin} и \texttt{cout} работали с файлами (\textit{перенаправить потоки ввода-вывода}), то в начале функции \texttt{main} нужно дописать:
	
	\begin{lstlisting}
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
	\end{lstlisting}
	
	Вместо \texttt{input.txt} и \texttt{output.txt} нужно использовать имена файлов, указанные в условии задачи.
	
	\subsubsection{Потоки \texttt{ifstream}, \texttt{ofstream}}
	
	Этот способ более универсален, так как позволяет работать с большим количеством файлов. Для работы с файлами этим способом требуется добавить строку \texttt{\#include <fstream>}. Чтобы работать с файлом для чтения и записи соответственно, напишите:
	
	\begin{lstlisting}
ifstream name_in("file_name");
ofstream name_out("file_name");
	\end{lstlisting}
	
	Вместо \texttt{file\_name} надо указать имя файла, вместо \texttt{name\_in}, \texttt{name\_out} --- любые имена для этих потоков. Работа с ними осуществляется так же, как и с \texttt{cin} и \texttt{cout} --- через \texttt{>>} и \texttt{<<}. Приведённые ниже два кода решают задачу нахождения суммы двух чисел, читая ввод из \texttt{in.txt} и записывая вывод в \texttt{out.txt}:

	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	freopen("in.txt", "r", stdin);
	freopen("out.txt", "w", stdout);
	int a, b;
	cin >> a >> b;
	cout << a + b;
}
	\end{lstlisting}

	\begin{lstlisting}
#include <fstream>

using namespace std;

ifstream fin("in.txt");
ofstream fout("out.txt");

int main() {
	int a, b;
	fin >> a >> b;
	fout << a + b;
}
	\end{lstlisting}
	
	\subsection{Интерактивные задачи}

	До этого мы сталкивались только со стандартными задачами: весь ввод дан нам в самом начале выполнения программы. Встречается и другой формат задач: \textit{интерактивные задачи}. Их отличие состоит в том, что программа-решение взаимодействует с программой жюри (называемой \textit{интерактором}) через стандартные потоки ввода-вывода. Рассмотрим пример интерактивной задачи:

	\task{Жюри загадало натуральное число от $1$ до $10$. Угадайте его. Вы можете называть число, а интерактор будет отвечать вам $1$, если вы угадали, и $0$ иначе. Если вы угадали, Ваша программа должна немедленно завершиться. Вы можете сделать $10$ запросов.}

	\begin{lstlisting}
#include<iostream>

using namespace std;

int main() {
	for (int i = 1; i <= 10; i++) {
		cout << i << '\n';
		cout.flush();
		int x;
		cin >> x;
		if (x == 1) {
			return 0;
		}
	}
}
	\end{lstlisting}

	Обратите внимание на строку \texttt{cout.flush();}. Она осуществляет \textit{сброс буфера потока вывода}.

	Для ускорения вывода C++ выводит данные на экран не сразу при выполнении команды \texttt{cout}, а накапливает их в буфере, а затем выводит. Команда \texttt{cout.flush()} осуществляет вывод всего содержимого буфера.

	\note{Интерактивные задачи часто используют идею \textit{бинарного поиска}, с которой вы познакомитесь в следующем году.}

	\subsection{Поиск ошибок с помощью \texttt{assert}}

	При написании большого кода, к сожалению, часто допускаются ошибки. С определением места, где они возникают, может помочь функция \texttt{assert}. Чтобы её использовать, нужно подключить библиотеку \texttt{cassert}. Функция \texttt{assert} принимает аргумент типа \texttt{bool}. Если аргумент равен Истине, то продолжается выполнение кода. Если же он равен Лжи, то программа завершается, выдав ошибку. Таким образом, посылка в тестирующей системе получит вердикт Ошибка исполнения, а не Неправильный ответ.

	\subsection{Как сократить код?}

	Название типов часто довольно длинные, например, \texttt{long long}, \texttt{long double}, \texttt{vector<int>}. Поэтому часто используются сокращения, например, \texttt{ll}, \texttt{ld}, \texttt{vi}. Чтобы объяснить компилятору, что мы имели в виду, есть несколько способов:

	\subsubsection{\texttt{using}}

	Пример:

	\begin{lstlisting}
#include <iostream>

using namespace std;
using ll = long long;

int main() {
	ll a, b;
	cin >> a >> b;
	cout << a + b;
}
	\end{lstlisting}

	Этот подход считается лучшим, но имеет важные ограничения: он позволяет сокращать только типы. 

	\subsubsection{\texttt{\#define}}

	Этот способ позволяет сокращать не только названия типов, но и любые названия, например, методы.

	\begin{lstlisting}
#include <iostream>
#include <vector>

using namespace std;

#define bg begin

int main() {
	vector<int> v = {5, 4};
	cout << *v.bg();
}
	\end{lstlisting}

	В таком случае говорят, что объявлен \textit{макрос} \texttt{bg}. Бывают и функции-макросы:

	\begin{lstlisting}
#include <iostream>

using namespace std;

#define sq(x) ((x) * (x))

int main() {
	cout << sq(5 + 3); // 64
}
	\end{lstlisting}

	Запись выше означает, что \texttt{sq(x)} будет преобразовано в \texttt{((x) * (x))}.

	\important{Скобки лишними не бывают!}

	Посмотрим, что будет, если убрать скобки:

	\begin{lstlisting}
#include <iostream>

using namespace std;

#define sq(x) x * x

int main() {
	cout << sq(5 + 3); // 23
}
	\end{lstlisting}

	Вывод изменился. Чтобы разобраться с причинами, посмотрим, во что превратится 8 строчка после замены:

	\begin{lstlisting}
	cout << 5 + 3 * 5 + 3;
	\end{lstlisting}

	Таким образом, \texttt{\#define} работает <<в лоб>>, поэтому скобки очень важны.

	\texttt{\#define} часто используется так:

	\begin{lstlisting}
#include <iostream>

using namespace std;

#define debug(x) cout << #x << " = " << x << '\n';

int main() {
	int x = 5;
	debug(x); // x = 5
	debug(x + 1) // x + 1 = 6
	debug("Hello") // "Hello" = Hello
}
	\end{lstlisting}

	В случае объявления макроса, \# перед названием его аргумента означает <<вставь сюда строку, которая соответствует тому, что было передано в макрос>>.

\end{document}
