\documentclass{article}
\usepackage[english,russian]{babel}
\usepackage[left=10mm, top=0mm, right=10mm, bottom=15mm, includehead]{geometry}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{graphbox}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tabularx}
\usepackage{float}
\DeclareTextSymbol{\cyrm}{\LastDeclaredEncoding}{236}
\DeclareTextSymbol{\cyrk}{\LastDeclaredEncoding}{234}
\graphicspath{ {./images/} }
\setcounter{tocdepth}{3}

\newcommand{\image}[2]{\includegraphics[height=#2]{images/#1.png}}
\newcommand{\imagen}[1]{\includegraphics{images/#1.png}}
\newcommand{\tab}{\ \ \ \:}
\newcommand{\Ohm}{\mathrm{\ \Omega}}
\newcommand{\kOhm}{\ \textrm{\cyrk}\Omega}
\newcommand{\V}{\mathrm{\ B}}
\newcommand{\A}{\mathrm{\ A}}
\newcommand{\mA}{\mathrm{\ \textrm{\cyrm} A}}
\newcommand{\p}{\varphi}
\newcommand{\tabularII}[1]{\begin{center}\begin{tabular}{|c|c|} #1 \end{tabular}\end{center}}
\newcommand{\tabularIII}[1]{\begin{center}\begin{tabular}{|c|c|c|} #1 \end{tabular}\end{center}}

\newcommand{\mathhelp}[1]{\textbf{\colorbox[rgb]{0.9,0.9,1}{Математическая справка}}. #1}
\newcommand{\stat}[1]{\textbf{Утверждение}. #1}
\newcommand{\style}[1]{\textbf{\colorbox[rgb]{0.9,1,0.9}{Стилистическая заметка}}. #1}
\newcommand{\important}[1]{\textbf{\colorbox[rgb]{1,0.9,0.9}{Важно}!} #1}
\newcommand{\note}[1]{\textbf{\colorbox[rgb]{1,1,0.9}{Замечание}}. #1}
\newcommand{\task}[1]{\textbf{Задача}. #1}
\newcommand{\exercise}[1]{\textbf{Упражнение}. #1}

\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}}
\renewcommand{\labelenumiii}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\title{Язык C++}
\author{Андрей Подшивалов}
\date{\today}

\begin{document}
	\lstset{language=C++, tabsize=4, numbers=left,  backgroundcolor=\color{backcolour},		commentstyle=\color{codegreen}, keywordstyle=\color{magenta}, numberstyle=\tiny\color{codegray}, stringstyle=\color{codepurple},	basicstyle=\ttfamily\footnotesize, showstringspaces=false}
	
	\maketitle
	\tableofcontents
	\newpage
	
	\section{Начало}
	
	\subsection{О структуре}
	
	Некоторые факты изложены в выделенных секциях. Ниже описано их предназначение.
	
	\mathhelp{Иногда в информатике требуются знания из математики, которые в курсах алгебры, геометрии и спецмата ещё не пройдены к моменту изучения в информатике. Такие факты приводятся в этой секции.}
	
	\style{Соблюдение этих правил настоятельно рекомендуется для поддержания читабельности кода и удобства его понимания. Но, вообще говоря, соблюдение данных правил не обязательно.}
	
	\important{У C++ есть свои странности, о которых важно помнить, чтобы Ваша программа работала так, как Вы хотите.}
	
	\note{В данной секции приводятся интересные факты или обращается внимание на некоторые факты.}
	
	\task{Так обозначаются задачи, формулируемые для последующего разбора.}
	
	Кроме того, \textit{курсивом} выделены новые термины, а важные, по мнению автора, факты \underline{подчёркнуты}.
	
	В коде после \texttt{//} указывается вывод или возвращаемое значение инструкции в данной строке.
	
	В случае ошибок, опечаток, предложений по оформлению и т.д. пишите \href{https://t.me/cpp_is_ok}{@cpp\_is\_ok} в Телеграмм.
	
	В случае вопросов по содержанию или по задачам пишите Боту помощи \href{https://t.me/inf54bot}{@inf54bot}.
	
	\subsection{Шаблон}
	
	Ниже приведён стандартный код на C++:
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	
}
	\end{lstlisting}
	
	Весь код, который мы будем писать в первом полугодии 8 класса, будет находиться внутри фигурных скобок. Пока будем использовать данный шаблон, не задумываясь, что значат все эти инструкции. Потом мы узнаем об их назначении. Часто в примерах далее мы будем опускать шаблон. В таком случае предполагается, что приведённый код находится внутри фигурных скобок.
	
	\style{Код внутри фигурных скобок принято писать \underline{с отступом в 4 пробела} в начале каждой строки. Скорее всего, редактор кода поможет Вам с поддержанием этого отступа.}
	
	\subsection{Переменные}
	\label{sec:variables}
	
	\textit{Переменная} --- это <<коробка>> для хранения чего-либо. У переменной есть:
	\begin{enumerate}
		\item{\textbf{Тип}. Каждая коробка подходит только для одного типа содержимого. Пока мы будем работать с целыми числами --- это один из возможных типов содержимого.}
		\item{\textbf{Значение}. Это и есть то, что лежит в коробке. Например, там может лежать число 54.}
		\item{\textbf{Имя}}. Некоторая последовательность символов, уникальная для каждой переменной. По ней в переменную можно записывать значения и получать значения.
	\end{enumerate}
	
	Каждая инструкция в C++ заканчивается точкой с запятой (\texttt{;}).
	
	Чтобы объявить переменную (создать коробку), нужно написать сначала тип переменной, затем её имя:
	
	\begin{center}
		\texttt{Type name;},
	\end{center}
	
	где \texttt{Type} --- тип переменной, с которыми мы будем знакомиться постепенно, а \texttt{name} --- имя переменной.
	
	Например, инструкция
	
	\begin{lstlisting}
int a;
	\end{lstlisting}
	
	создаёт переменную с именем \texttt{a} типа целое число (\texttt{int} от англ. integer --- целое). В названии можно использовать любые английские буквы (как заглавные, так и строчные), нижнее подчеркивание (\_) и цифры, но название не может начинаться с цифры. Название переменной может содержать любое количество символов. Название переменной не должно совпадать с ключевыми словами (с ними мы будем постепенно знакомиться в следующих главах) и типами данных. В таблице ниже приведены примеры корректных и некорректных имён переменных.
	
	\tabularII{
		\hline
		\textbf{Корректные} & \textbf{Некорректные}\\
		\hline
		a2 & 2a\\
		\hline
		number\_of\_letters & number-of-letters\\
		\hline
		numberOfLetters & number of letters\\
		\hline
		int\_ & int\\
		\hline
	}
	
	\style{Хорошо давать переменным имена, из которых следует содержимое переменных. Исключением является размер входных данных: если в условии сказано, что программе будет передано некоторое количество целых чисел, то это количество обычно обозначается $n$ (или $m$).}
	
	Чтобы \textit{присвоить значение} переменной (положить что-либо в коробку, \underline{навсегда утратив} предыдущее её содержимое), нужно написать через равно имя переменной и новое её значение. Например, чтобы присвоить уже объявленной переменной \texttt{a} число 54, нужно написать:
	
	\begin{lstlisting}
a = 54;
	\end{lstlisting}
	
	Таким образом, чтобы объявить переменную \texttt{letter\_num} и присвоить ей значение 5, нужно написать:
	
	\begin{lstlisting}
int letter_num;
letter_num = 5;
	\end{lstlisting}
	
	Вместо этого есть более короткая запись:
	
	\begin{lstlisting}
int letter_num = 5;
	\end{lstlisting}
	
	Можно объявлять несколько переменных одного типа в одной строке:
	
	\begin{lstlisting}
int a, b = 5, c = 4;
	\end{lstlisting}
	
	Эта строка объявляет переменные \texttt{a}, \texttt{b} и \texttt{c}. Переменным \texttt{b} и \texttt{c} заданы значения (5 и 4 соответственно). Переменная \texttt{a} создана, но \textit{не инициализирована}. Это значит, что в ней может храниться любое значение, пока оно не будет задано явно.
	
	Используя \texttt{равно}, можно сохранять значение одной переменной в другую. Например, если в переменной \texttt{b} хранится значение $5$, то после инструкции
	
	\begin{lstlisting}
int a = b;
	\end{lstlisting}
	
	будет создана переменная \texttt{a}, в которой тоже будет храниться число $5$.
	
	Когда некоторое число используется в коде несколько раз, то хорошим стилем написания кода является определение \textit{константы}. Это переменная, значение которой может быть присвоено только при создании. При попытке далее в программе изменить значение константы программа не может быть собрана, что гарантирует сохранность одного значения на протяжении всего выполнения кода.
	
	Чтобы объявить константу, перед названием типа надо написать \texttt{const}:
	
	\begin{lstlisting}
const int SYSTEM_BASE = 10;
	\end{lstlisting}
	
	\style{Для именования констант используют только заглавные буквы и нижние подчёркивания, как в примере выше.}
	
	\style{Любую константу (кроме $0$ и $1$) следует явно объявлять как константы.}
	
	\subsection{Арифметические операции}
	
	В данном параграфе мы научимся совершать арифметические операции --- сложение, вычитание, умножение, деление, остаток от деления. В таблице ниже приведены обозначения этих операций в C++:
	
	\tabularII{
		\hline
		сложение & +\\
		\hline
		вычитание & -\\
		\hline
		умножение & *\\
		\hline
		деление & /\\
		\hline
		остаток от деления & \%\\
		\hline
	}
	
	Эти операции можно совершать как с числами, так и с переменными. В одном выражении можно использовать и числа, и переменные. Порядок действий по умолчанию --- как в математике. Приоритет остатка от деления такой же, как у деления. Чтобы повлиять на порядок действий, можно использовать круглые скобки.
	
	\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/} --- это \textit{бинарные операторы}. Это значит, что они совершают некоторое действие с двумя \textit{операндами} --- теми объектами, которые они разделяют. На самом деле, \texttt{=} --- тоже бинарный оператор, называемый \textit{оператором присваивания}.
	
	Следующий код сохраняет числа 5 и 4 в переменные \texttt{a} и \texttt{b}, а затем сохраняет их сумму в переменную \texttt{c}.
	
	\begin{lstlisting}
#include<iostream>

using namespace std;

int main() {
	int a = 5, b = 4;
	int c = a + b;
}
	\end{lstlisting}
	
	\style{Хорошо ставить пробелы с обеих сторон от оператора, как в примере выше. Также пробел ставится после запятой, но не до неё.}
	
	\mathhelp{\textit{Разделить} целое число $a$ на натуральное число $b$ \textit{с остатком} значит представить $a$ в виде $qb+r$, где $q$ и $r$ целые, и $0\le r < b$. Тогда число $q$ называется \textit{неполным частным}, а число $r$ \textit{остатком} при делении числа $a$ на число $b$.}
	
	Операция деления (\texttt{/}) над целыми числами возвращает именно \textbf{неполное частное}. Например, \texttt{5/2} равно $2$.
	
	\important{При делении отрицательного числа на положительное C++ не соблюдает правила математики. Он делает операции так, будто это положительное число, а затем добавляет неполному частному и остатку знак минус. Например, $(-5) \% 3 = -2$, $(-5) / 3 = -1$, так как $-5=(-3)\cdot(-1)+(-2)$.}
	
	Если Вам нужен остаток от деления, как в математике, для деления $a$ на $b$ можно использовать следующую конструкцию:
	
	\begin{lstlisting}
((a % b) + b) % b
	\end{lstlisting}
	
	Кроме того, есть \textit{унарный оператор} $-$. Это значит, что он совершает операцию, имеющую только один операнд (который идет после оператора). При таком использовании он меняет знак у операнда. Например, после выполнения кода
	
	\begin{lstlisting}
int a = 5;
int b = -a;
	\end{lstlisting}
	
	в переменной \texttt{b} будет храниться число $-5$.
	
	\subsection{Обработка цифр числа}
	
	Научимся обрабатывать цифры числа. Для этого узнаем, как совершать два типа операций:
	
	\begin{enumerate}
		\item{Удаление последней цифры}
		\item{Получение последней цифры}
	\end{enumerate}
	
	\mathhelp{Если над некоторым набором переменных стоит палочка, это значит, что рассматривается число, цифры которого --- значения переменных. Например, если $a=5, b=4$, то $\overline{ab}=54$, а $ab = a\cdot b = 20$. Палочка используется для того, чтобы не путать запись цифр числа и перемножение.}
	
	Рассмотрим некоторое натуральное число $a=\overline{a_n a_{n - 1}\dots a_0}$. Разложим его на разрядные слагаемые и проведём некоторые преобразования: $a=a_n \cdot 10^n + a_{n - 1} \cdot 10^{n - 1} + \dots + a_0 = 10 (a_n \cdot 10^{n - 1} + a_{n - 1} \cdot 10^{n - 2} + \dots + a_1) + a_0=10\overline{a_n a_{n - 1} \dots a_1} + a_0$. $a_0 < 10$, и $\overline{a_n a_{n - 1} \dots a_1}$ и $a_0$ целые, поэтому по определению деления с остатком $a_0$ --- остаток, $\overline{a_n a_{n - 1}\dots a_1}$ --- неполное частное при делении на $10$.
	
	Тогда если взять остаток от деления некоторого числа на $10$, то мы получим его последнюю цифру, а если поделить его нацело на $10$, то удалим её.
	
	\subsection{Про тип данных \texttt{long long}}
	
	В п. \ref*{sec:variables} мы познакомились с типом данных \texttt{int}. На самом деле, он умеет вмещать в себя только числа в диапазоне $[-2^{31}; 2^{31} -1]$ (примерно от $-2\cdot 10^9$ до $2\cdot 10^9$). Но часто требуется работать с б'ольшими числами. Тип данных \texttt{long long} позволяет работать с числами в диапазоне $[-2^{63}; 2^{63}-1]$ (примерно от $-9\cdot 10^{18}$ до $9\cdot 10^{18}$). Операции над типом \texttt{long long} совершаются так же, как и над типом \texttt{int}. Но помните, что при перемножении двух чисел типа \texttt{int} результат будет считаться тоже в типе int. Поэтому следующий код \textbf{содержит ошибку}:
	
	\begin{lstlisting}
int a = 1000000000;
long long b = a * a;
	\end{lstlisting}
	
	Результат перемножения считается в типе \texttt{int}, в который не помещается. Есть несколько возможных способов исправления этой ошибки:
	
	\begin{lstlisting}
long long a = 1000000000;
long long b = a * a;
	\end{lstlisting}
	
	или
	\begin{lstlisting}
int a = 1000000000;
long long b = 1ll * a * a;
	\end{lstlisting}
	
	Обратите внимание, что если после числа написано \texttt{ll}, то оно имеет тип \texttt{long long}. Если умножить \texttt{int} на \texttt{long long}, то получится \texttt{long long}. Поэтому первое умножение в коде выше приведет \texttt{a} к типу \texttt{long long}.
	
	\subsection{Ввод-вывод}
	
	Обычно от программы требуется какое-либо взаимодействие с пользователем. Поэтому в C++, как и во всех других языках программирования, реализован ввод с клавиатуры и вывод на экран. Доступ к вводу осуществляется через \texttt{cin} (от англ. console input --- консольный ввод) --- особый объект. Чтобы считать число, например, в переменную \texttt{a}, нужно написать следующую инструкцию:
	
	\begin{lstlisting}
cin >> a;
	\end{lstlisting}
	
	(Помните, что перед работой с переменной её надо обязательно объявить!)
	
	Кроме того, можно считывать несколько чисел одной инструкцией:
	
	\begin{lstlisting}
cin >> a >> b >> c;
	\end{lstlisting}
	
	При этом при вводе числа могут разделяться как переводами строк (\texttt{Enter}), так и пробелами.
	
	Для вывода используется другой объект --- \texttt{cout} (от англ. console output --- консольный вывод). Чтобы вывести содержимое переменной \texttt{a}, нужно написать:
	
	\begin{lstlisting}
cout << a;
	\end{lstlisting}
	
	Выводить можно не только переменные, но и числа. Также, как и со вводом, можно выводить несколько объектов за раз. Но учитывайте, что если вывести сначала число 1, а затем число 5, то на экране будет выведено 15. Пробелы или переводы строк нужно выводить самостоятельно. Чтобы вывести пробел, выведите \texttt{' '}. Чтобы вывести перевод строки, выведите \texttt{endl} или \texttt{'\textbackslash n'}. Следует помнить, что \texttt{'\textbackslash n'} работает быстрее, чем \texttt{endl}. Пример:
	
	\begin{lstlisting}
cout << 5 << ' ' << 6 << 7 << '\n' << 8 + 3 << endl << 9;
	\end{lstlisting}
	Эта строка выведет:\\
	\texttt{
	5 67\\
	11\\
	9}
	
	Напишем программу, которая считывает 2 числа и выводит на экран их сумму:
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int a, b;
	cin >> a >> b;
	cout << a + b;
}
	\end{lstlisting}
	
	\subsection{Вычисления по модулю}
	
	В случае, когда ответ слишком большой и не помещается в тип \texttt{long long}, часто требуется вывести его по модулю $10^9+7$ или какому-либо другому. Это значит, что надо найти остаток от деления ответа на заданное число. Для решения таких задач полезно помнить следующее утверждение:
	
	\stat{Остаток суммы (разности, произведения) при делении на $m$ равен остатку суммы (разности, произведения) остатков некоторого количества чисел при делении на $m$.}
	
	\subsection{Установка и использование Code::Blocks (Windows)}
	
	Мы будем работать со средой \texttt{Code::Blocks}. В случае, если вы хотите более красивую среду и у вас \texttt{Linux}, то перейдите в раздел 8.3, в котором описывается установка среды VS Code. В случае, если у вас Windows и вы хотите установить VS Code, можете написать в бота, мы постараемся вам помочь.
	
	Чтобы установить Code::Blocks, перейдите на страницу {\color{blue}\href{https://www.codeblocks.org/downloads/binaries/}{https://www.codeblocks.org/downloads/binaries/}}. Выберите файл \texttt{codeblocks-20.03mingw-setup.exe}. Нажмите FossHUB рядом с ним. Установите файл и запустите его. Оставляйте все настройки по умолчанию. После этого запустите Code::Blocks.
	
	\begin{enumerate}
		\item {Работать будем в проектах. Чтобы создать проект, нажмите на кнопку \texttt{Create a new project}.} 
	
		\image{cb1}{220px}
		
		\item {Выберите \texttt{Console application}.}
		
		\image{cb2}{220px}
		
		\item {Нажмите \texttt{Next}. Выберите C++, нажмите \texttt{Next}. Разберемся с следующим окном подробнее:}
		
		\image{cb3}{150px}
		
		\item {Укажите любое имя проекта (\texttt{Project title}) и папку, где проект будет создан (\texttt{Folder to create project in}). Для выбора папки нажмите на многоточие (обведено красным на картинке выше). Нажмите \texttt{Next}.}
		
		\item {Нажмите \texttt{Finish}.}
	
	\end{enumerate}
	
	Проект создан. Теперь научимся открывать файл, в котором будем писать код.
	
	\begin{enumerate}
		\item {Если у Вас открыта панель \texttt{Management} (слева), то откройте там вкладку \texttt{Projects}. Откройте все подпапки (нажав на плюс слева от названий). Нажмите дважды на \texttt{main.cpp}}
		
		\image{cb4}{150px}
		
		\item {Если панели \texttt{Management} нет, нажмите комбинацию клавиш \texttt{Shift + F2}.}
	\end{enumerate}
	
	Чтобы запустить код, нажмите клавишу \texttt{F9} или на значок \imagen{cb5}.
	
	\subsection{Структура олимпиадной задачи}
	
	Обычно олимпиадная задача состоит из нескольких частей. Разберем их все по отдельности:
	
	\begin{enumerate}
		\item{\textbf{Ограничения}. Здесь указаны ограничения по времени и памяти. Если Ваша программа будет их превышать, вы получите вердикт Превышено ограничение времени (TL или TLE --- от Time Limit Exceeded) или Превышено ограничения памяти (ML или MLE --- от Memory Limit Exceeded).}
		\item{\textbf{Имя входного/выходного файла}. Обычно здесь написано стандартный поток ввода (или \texttt{stdin}) и стандартный поток вывода (\texttt{stdout}). Если указано что-то иное, то входные данные надо читать из одного файла, а выходные данные выводить в другой файл, названия которых указаны в этой секции. О работе с файлами см. п. \ref*{sec:files}.}
		\item{\textbf{Легенда}. Условия задач по программированию обычно содержат какую-либо интересную легенду. Например, людям дарят граф на Новый год. Но на начальном этапе, скорее всего, Вы будете встречаться с формальными условиями задач. В этой части описано общее содержание задачи.}
		\item{\textbf{Входные данные}. В этой части описывается формат входных данных --- того, что подаётся Вашей программе на вход. Также здесь описываются ограничения на размер входных данных, чтобы Вы могли подобрать алгоритм, который при таких ограничениях укладывается в отведённое время.}
		\item{\textbf{Выходные данные}. В этой части описывается формат выходных данных --- того, что должна выводить Ваша программа.}
		\item{\textbf{Система оценки}. Здесь описывается оценка задачи. Подробнее про оценку задачи см. п. \ref*{sec:task-scoring}. При \texttt{ICPC}-формате эта секция отсутствует. В \texttt{IOI}-формате здесь приводятся ограничения на каждую из подгрупп или указывается на потестовую оценку.}
		\item{\textbf{Примеры}. Здесь приводятся один или несколько примеров входных данных и соответствующих им выходных данных. \underline{Обратите внимание}, что в тестирующей системе есть другие тесты, которые неизвестны Вам. Поэтому программа должна работать не только на тестах из условия, но и в общем случае.}
		\item{\textbf{Замечание}. В этой секции объясняются примеры или даются иные комментарии по задаче. Часто эта секция отсутствует.}
	\end{enumerate}
	
	\subsection{Оценка олимпиадной задачи}
	
	Есть два наиболее популярных вида оценки задач:
	
	\begin{enumerate}
		\item{{\large ICPC}\\
			Каждая задача либо зачтена, либо не зачтена. Чтобы задача была зачтена (вердикт \texttt{OK}/\texttt{AC}/\texttt{Полное решение}, нужно, чтобы решение прошло все тесты). Скорее всего, большая часть школьных задач и задач на обучающих курсах будет именно в этом формате. Этот формат используется на Внутренней олимпиаде 54-ой школы (начиная с IV-ой) и на командных олимпиадах, как среди школьников, так и среди студентов.
			
			\textbf{Штраф}. Так как возможных результатов довольно мало (количество задач плюс 1), то участники, решившие одинаковое число задач, упорядочивается по штрафу. Штраф зависит от времени, прошедшего с начала соревнования до успешной сдачи задачи, и от количества неудачных посылок. \underline{В учебных задачах штраф не важен}.
		}
		
		\item{{\large IOI}\\
			В этом формате каждое решение оценивается некоторым количеством баллов (обычно от 0 до 100). Количество баллов может определяться по-разному. Ниже приведены два наиболее распространённых вида:
			\begin{enumerate}
				\item{\textbf{Оценка по подгруппам}. Задача разбита на несколько подгрупп. На каждую подгруппу, кроме, скорее всего, последней, наложены дополнительные условия, упрощающие задачу. Обычно баллы за подгруппу ставятся тогда, когда пройдены все тесты этой подгруппы.}
				\item{\textbf{Потестовая оценка}. В задаче $n$ тестов, кроме тестов из условия, и каждый из них стоит $\dfrac{100}{n}$ баллов.}
			\end{enumerate}
			
			Этот формат используется на всех этапах Всероссийской олимпиады школьников, Летнем кубке по программированию 54-ой школы, на многих перечневых олимпиадах и на Международной олимпиаде по информатике (\texttt{IOI}). I-III Внутренние олимпиады 54-ой школы также использовали этот формат.
		}
	\end{enumerate}

	\subsection{Вердикты тестирующей системы}
	\label{sec:task-scoring}

	Ниже приведены наиболее часто встречающиеся вердикты:

	\begin{table}[H]
    \centering
    \begin{tabularx}{\textwidth}{|X|X|X|X|}
        \hline
		\textbf{Полное название} & \textbf{Английское название} & \textbf{Сокращение} & \textbf{Причины} \\
		\hline
		Полное решение & OK/Accepted & OK/AC & Решение работает верно на всех тестах жюри\\
		\hline
		Неправильный ответ & Wrong answer & WA & Решение выводит неверный ответ\\
		\hline
		Превышено время исполнения & Time Limit (Exceeded) & TL/TLE & Решение работает слишком долго (из-за неподходящего алгоритма или ошибки в реализации)\\
		\hline
		Превышен лимит по памяти & Memory Limit (Exceeded) & ML/MLE & Решение выделяет слишком много памяти\\
		\hline
		Ошибка исполнения & Runtime Error & RE & Решение исполняется с ошибкой\\
		\hline
		Ошибка компиляции & Compilation Error & CE & Решение не компилируется\\
		\hline
		Ошибка представления & Presentation Error & PE & Формат вывода программы не соответствует выходным данным. В некоторых системах отображается как WA.\\
		\hline
    \end{tabularx}
	\end{table}

	Далее приведены специфичные вердикты:

	\begin{table}[H]
    \centering
    \begin{tabularx}{\textwidth}{|X|X|X|X|}
		\hline
		\textbf{Полное название} & \textbf{Английское название} & \textbf{Сокращение} & \textbf{Причины} \\
		\hline
		Нарушение стиля оформления программ & Style Violation & SV & Пробелы в коде стоят не там, где надо, отступы не соответствуют требуемым и т.д.\\
		\hline
		Ожидает подтверждения & Pending Review & PR & Посылка прошла тесты, но ожидает ручного подтверждения\\
		\hline
		Отклонено & Rejected & RJ & Преподаватель признал попытку неверной\\
		\hline
		Превышен лимит бездействия/Решение <<зависло>> & Idleness Limit (Exceeded) & IL/ILE & Этот вердикт предназначен для интерактивных задач (подробнее см. п. \ref*{sec:interactive}) и возникает, когда программа слишком долго не взаимодействует с интерактором. Обычно происходит, если в решении не сбрасывается буфер потока вывода.\\
		\hline
	\end{tabularx}
	\end{table}
	
	\subsection{Числа с плавающей точкой (Дробные числа)}
	
	До этого мы работали только с целыми числами. Теперь познакомимся с дробными числами. Из-за особенностей их хранения в памяти, вычисления с ними не точны, поэтому лучше использовать целые числа, если есть такая возможность.
	
	Для хранения в памяти дробных чисел существуют типы \texttt{float}, \texttt{double}, \texttt{long double}. Каждый из них умеет хранить числа точнее, чем предыдущий. Не рекомендуется использовать тип \texttt{float} из-за его маленькой точности. Арифметические операции осуществляются с ними так же, как и с целыми. Но оператор деления делит не нацело, а <<как в математике>> $\left(\dfrac{5.0}{2.0}=2.5\right)$. Для выполнения деления без округления хотя бы один из операндов должен быть числом с плавающей точкой. Для приведения целого числа к типу \texttt{double} его можно умножить на \texttt{1.0}, для приведения к типу \texttt{long double} --- на \texttt{1.0l}. Суффикс \texttt{l} (латинская строчная L) показывает, что число имеет тип \texttt{long double}.
	
	Обратите внимание, что десятичным разделителем является точка.
	
	Еще одна возможная форма записи чисел с плавающей точкой --- научная. Например, \texttt{2.4e6} означает то же, что и $2.4 \cdot 10 ^ 6$. Для записи больших целых чисел тоже используется такой формат. Например, можно часто встретить
	
	\begin{lstlisting}
const int INF = 2e9;
	\end{lstlisting}
	
	или 
	
	\begin{lstlisting}
const int MOD = 1e9 + 7;
	\end{lstlisting}
	
	Но на самом деле, C++ создает дробное число, а затем преобразует его к целому.
	
	Есть особенность, связанная с выводом чисел с плавающей точкой. Познакомимся с ней на примере. Запустим следующий код:
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	long double a = 1001;
	cout << a * a * a << '\n';
}
	\end{lstlisting}
	
	Этот код считает $1001^3$ в дробных числах. Мы ожидаем получить ответ $1003003001$, но после запуска увидим $1.003e+09$. Ответ посчитан верно, но с очень низкой точностью. В задачах обычно указана точность ответа, но лучше всегда выводить максимальное возможное количество знаков после запятой, если вывод лишних знаков не противоречит условию. Чтобы управлять точностью выводимых чисел, допишите после \texttt{\#include <iostream>} строку \texttt{\#include <iomanip>}. В следующей строке после \texttt{int main() \{} напишите \texttt{cout << fixed << setprecision(k);}, где вместо $k$ укажите количество цифр, которое необходимо вывести. Этот код всегда будет выводить $k$ цифр после запятой. Если не требуется выводить нули после запятой, можно опустить \texttt{fixed <<}.
	
	Тогда наш исправленный код будет выглядеть так:
	
	\begin{lstlisting}
#include <iostream>
#include <iomanip>

using namespace std;

int main() {
	cout << fixed << setprecision(100);
	long double a = 1001;
	cout << a * a * a << '\n';
}
	\end{lstlisting}
	
	\subsection{Развеевание магии}
	
	Поговорим о назначении команд \texttt{\#include}.
	
	Команда \texttt{\#include} \textit{подключает библиотеки}, то есть позволяет использовать код, написанный другими разработчиками (в олимпиадном программировании --- обычно авторами языка). Название библиотек указывается в треугольных кавычках. Приведём наиболее популярные из встроенных библиотек:
	
	\begin{tabularx}{\textwidth}{|X|X|}
		\hline
		\textbf{Название} & \textbf{Описание}\\
		\hline
		\texttt{iostream} & Работа с вводом-выводом\\
		\hline
		\texttt{iomanip} & Настройка ввода-вывода (точность вывода дробных чисел и т.п.)\\
		\hline
		\texttt{cmath} & Расширенная математика (см. след. раздел)\\
		\hline
		\texttt{vector} & Векторы (динамические массивы) --- будут рассмотрены позже\\
		\hline
		\texttt{algorithm} & Алгоритмы (сортировка, бинарный поиск). Вы познакомитесь с ней в 9 классе\\
		\hline
	\end{tabularx}
	
	Команда \texttt{using namespace std;} позволяет нам писать код короче. Например, задача <<ввести 2 числа и найти их сумму>> без неё решается так:
	
	\begin{lstlisting}
#include <iostream>

int main() {
	int a, b;
	std::cin >> a >> b;
	std::cout << a + b << std::endl;
}
	\end{lstlisting}
	
	На написание такого кода требуется больше времени, но в промышленной разработке такой способ предпочтительнее, так как позволяет использовать одно и то же название несколько раз.
	
	\subsection{Расширенная математика}
	
	Мы научились выполнять арифметические операции. Но часто требуются и другие математические операции: корень, тригонометрические функции, логарифм. Чтобы использовать их, требуется подключить библиотеку \texttt{cmath}.
	
	Ниже приведена таблица функций:
	
	\tabularII{
		\hline
		\textbf{Название в C++} & \textbf{Описание}\\
		\hline
		sqrt & Квадратный корень\\
		\hline
		cbrt & Кубический корень\\
		\hline
		pow & Возведение в степень\\
		\hline
		abs & Модуль\\
		\hline
		log & Натуральный логарифм\\
		\hline
		log10 & Десятичный логарифм\\
		\hline
		log2 & Двоичный логарифм\\
		\hline
		sin, cos, tan & Тригонометрические функции\\
		\hline
		asin, acos, atan & Обратные тригонометрические функции\\
		\hline
		floor, ceil, round & Округление (вниз, вверх, к ближайшему)\\
		\hline
		M\_PI & Число Пи\\
		\hline
	}
	
	\important{Все тригонометрические функции работают в радианах ($1\ \text{радиан} = \frac{\pi}{180}^\circ$).}
	
	\important{Возведение в степень работает только в дробных числах, поэтому в случае целых чисел надёжнее реализовать руками.}
	
	\section{Ветвление}
	
	\subsection{Тип данных \texttt{bool}. Логические условия}
	
	На данный момент нам известно два типа данных --- \texttt{int} и \texttt{long long}. Познакомимся ещё с одним типом данных --- \texttt{bool}. Тип данных \texttt{bool} хранит одно из двух возможных значений: \texttt{Истина (да)} или \texttt{Ложь (нет)}. Например, выражение $5>4$ равносильно \texttt{Истине}, а $5>5$ равносильно \texttt{Лжи}. В C++ \texttt{Истина} обозначается \texttt{true}, а \texttt{Ложь} --- \texttt{false}. Вы можете создать переменную типа \texttt{bool} так же, как и переменную других известных Вам типов:
	
	\begin{lstlisting}
bool a;
	\end{lstlisting}
	
	или
	
	\begin{lstlisting}
bool a = true;
	\end{lstlisting}
	
	Также можно выводить переменную типа \texttt{bool}. При выводе значения \texttt{true} будет напечатана единица, при выводе \texttt{false}\;--- ноль. При вводе \texttt{bool} происходит считывание числа. Если оно равно $0$, то результатом будет \texttt{false}; иначе результатом будет \texttt{true}.
	
	В C++ есть возможность сравнивать числа с помощью операторов $>$, $<$, $\ge$, $\le$, $=$, $\ne$, но форма их записи отличается. В таблице ниже приведено обозначение этих операторов в C++:
	
	\tabularII{
		\hline
		\textbf{Математика} & \textbf{C++}\\
		\hline
		$>$ & \texttt{>}\\
		\hline
		$<$ & \texttt{<}\\
		\hline
		$\ge$ & \texttt{>=}\\
		\hline
		$\le$ & \texttt{<=}\\
		\hline
		$=$ & \texttt{==}\\
		\hline
		$\ne$ & \texttt{!=}\\
		\hline
	}
	
	Результат сравнения имеет тип \texttt{bool}. Например, после выполнения кода
	
	\begin{lstlisting}
bool a = 5 > 3;
	\end{lstlisting}
	
	в переменной \texttt{a} будет храниться значение \texttt{true}.
	
	\subsection{Операторы над типом \texttt{bool}}
	
	Тип \texttt{bool} кажется довольно странным, но позже мы увидим, что он часто оказывается полезен. Пока познакомимся с операторами для работы с этим типом. В таблице ниже приведены названия и обозначения в C++ каждого из операторов.
	
	\tabularII{
		\hline
		\textbf{Оператор в C++} & \textbf{Название}\\
		\hline
		\&\& & логическое И\\
		\hline
		$\vert\vert$ & логическое ИЛИ\\
		\hline
		== & равенство\\
		\hline
		!= & неравенство\\
		\hline
	}
	
	Последние два оператора работают так же, как и с остальными типами данных. Остановимся на первых двух подробнее.
	
	Результат логического И для двух операндов истинен тогда и только тогда, когда оба операнда истинны. Таблица истинности для этого оператора:
	
	\tabularIII{
		\hline
		\textbf{$A$} & \textbf{$B$} & \textbf{$A\&\&B$}\\
		\hline
		\texttt{false} & \texttt{false} & \texttt{false}\\
		\hline
		\texttt{false} & \texttt{true} & \texttt{false}\\
		\hline
		\texttt{true} & \texttt{false} & \texttt{false}\\
		\hline
		\texttt{true} & \texttt{true} & \texttt{true}\\
		\hline
	}
	
	Результат логического ИЛИ истинен тогда и только тогда, когда хотя бы один из двух операндов истинен. Таблица истинности для него:
	
	\tabularIII{
		\hline
		\textbf{$A$} & \textbf{$B$} & \textbf{$A\vert\vert B$}\\
		\hline
		\texttt{false} & \texttt{false} & \texttt{false}\\
		\hline
		\texttt{false} & \texttt{true} & \texttt{true}\\
		\hline
		\texttt{true} & \texttt{false} & \texttt{true}\\
		\hline
		\texttt{true} & \texttt{true} & \texttt{true}\\
		\hline
	}
	
	Кроме того, для типа \texttt{bool} определён унарный оператор отрицания, обозначаемый \texttt{!}. Он меняет значение, к которому применяется, на противоположное. Таким образом, его таблица истинности выглядит так:
	
	\tabularII{
		\hline
		\textbf{$A$} & \textbf{$!A$}\\
		\hline
		\texttt{false} & \texttt{true}\\
		\hline
		\texttt{true} & \texttt{false}\\
		\hline
	}
	
	\style{Напоминаем, что бинарные операторы (в т.ч. логические) отделяются от своих операндов пробелами. Между унарным оператором и его операндом пробел не ставится.}
	
	\note{Если логическим операторам передавать числа как операнды, то они будут преобразованы к типу \texttt{bool} по следующему правилу: $0$ преобразуется в \texttt{false}, все остальные числа --- в \texttt{true}.}
	
	\subsection{Неполное ветвление. Ключевое слово \texttt{if}}
	
	Мы научились сравнивать числа. Но сейчас наша программа выполняется строчка за строчкой, мы пока не можем выполнять различные действия в зависимости от некоторых условий. Но такая возможность есть, и в этом пункте мы познакомимся с ней. Фраза <<Если выполнено условие A, то сделай B>> на C++ записывается так:
	
	\begin{lstlisting}
if (A) {
	B;
}
	\end{lstlisting}
	
	После выполнения этого блока кода, будет выполнена следующая после закрывающей фигурной скобки строчка.
	
	<<Место B>> называется \textit{телом} условной конструкции, A --- \textit{условием}.
	
	Тело может состоять из нескольких инструкций.
	
	Напишем код, который выполняет следующий следующий алгоритм:
	
	\begin{enumerate}
		\item{Считать число.}
		\item{Если число больше 5, вычесть из него 1.}
		\item{Вывести число.}
	\end{enumerate}
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int x;
	cin >> x;
	if (x > 5) {
		x = x - 1;
	}
	cout << x << '\n';
}
	\end{lstlisting}
	
	\style{Отступ в теле условной конструкции должен быть на один tab (4 пробела) больше, чем отступ вне её.}
	
	Условие может состоять из нескольких логических выражений, объединённых логическими операторами, которые мы изучили ранее. Решим следующую задачу:
	
	\task{Вводится целое число $x$. Если $5\le x\le 10$, то выведите $1$, иначе не выводите ничего.}
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int x;
	cin >> x;
	if (x >= 5 && x <= 10) {
		cout << 1;
	}
}
	\end{lstlisting}
	
	\important{Запись \texttt{5 <= x <= 10} в C++ не равносильна математическому двойному неравенству $5\le x\le 10$, в отличие от других языков (например, Python), которые могут допускать такую запись. Корректно писать так, как в приведённом выше примере.}
	
	\subsubsection{Область видимости переменной}
	
	\important{Переменная, объявленная внутри фигурных скобок доступна только внутри них. Например, следующий код \textbf{содержит ошибку}, так как переменная \texttt{b} была объявлена внутри \texttt{if} и доступна только в его теле. Но в теле условной конструкции можно получать доступ к переменной \texttt{a}, так как тело условной конструкции находится внутри фигурных скобок \texttt{main}.}
	
	\begin{lstlisting}
#include<iostream>

using namespace std;

int main() {
	int a = 5;
	if (a > 3) {
		int b = 10;
	}
	cout << b;
}
	\end{lstlisting}
	
	Тот участок кода, где переменная доступна, называется \textit{областью видимости} этой переменной.
	
	\subsection{Полное ветвление. Ключевое слово \texttt{else}}
	
	Ключевое слово \texttt{else} может идти только после условной конструкции. Синтаксис при его использовании таков:
	
	\begin{lstlisting}
if (A) {
	B;
} else {
	C;
}
	\end{lstlisting}
	
	Блоки \texttt{A} и \texttt{B} были разобраны в прошлом пункте. Инструкции блока \texttt{C} выполняются только в том случае, когда не выполнилось условие \texttt{A}. В блоке \texttt{C}, как и в блоке \texttt{B}, может быть несколько инструкций. Например, в прошлом пункте мы решали задачу о принадлежности числа отрезку $[5; 10]$. Если число не принадлежало отрезку, то мы ничего не выводили. Давайте в таком случае выведем $0$:
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int x;
	cin >> x;
	if (x >= 5 && x <= 10) {
		cout << 1;
	} else {
		cout << 0;
	}
}
	\end{lstlisting}
	
	\subsection{Использование \texttt{else-if}}
	
	Мы научились делать что-либо, если какое-то условие выполнено, и научились выбирать из двух вариантов действий нужный, исходя из истинности условия. Теперь рассмотрим, что делать, если вариантов действий больше двух. Например, решим такую задачу:
	
	\task{Требуется определить возрастную категорию человека по его возрасту в годах $x$. Если человеку ещё нет $7$ лет, отнесём его к категории $0$ (дошкольники), если уже есть $7$, но ещё нет $18$, --- к категории $1$ (школьники), если есть $18$ --- к категории $2$ (взрослые).}
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int x;
	cin >> x;
	if (x < 7) {
		cout << 0;
	} else if (x < 18) {
		cout << 1;
	} else {
		cout << 2;
	}
}
	\end{lstlisting}
	
	Когда C++ видит такую конструкцию, он последовательно проверяет условия. Когда он находит истинное, он выполняет тело после этого условие, а затем пропускает все остальные. Если ни одно из условий не выполнилось, выполняется тело \texttt{else}. Именно поэтому во втором условии нет проверки $x\ge 7$, так как, если это условие было бы не выполнено, то выполнился бы первый блок.
	
	Конструкций \texttt{else-if} может быть много. Например,
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int x;
	cin >> x;
	if (x < 7) {
		cout << 0;
	} else if (x < 18) {
		cout << 1;
	} else if (x < 35) {
		cout << 2;
	} else {
		cout << 3;
	}
}
	\end{lstlisting}
	
	\subsection{Вывод текста на экран}
	
	Часто в задачах, где надо проверить какие-либо условия, требуется вывести <<YES>> или <<NO>>. Чтобы вывести текст, надо записать его в кавычках (\texttt{"}), чтобы C++ не думал, что слова в нём --- названия переменных. Например, чтобы вывести <<YES>> (без кавычек), нужно написать:
	
	\begin{lstlisting}
cout << "YES";
	\end{lstlisting}
	
	\section{Циклы. Цикл с предусловием. Цикл <<$n$ раз>>. Цикл с постусловием. Вложенные циклы.}
	
	Наш код уже может выполняться по-разному в зависимости от разных условий. Теперь рассмотрим способы <<зациклить>> наш алгоритм --- повторить его некоторое количество раз. Перед этим познакомимся с составными арифметическими операторами, которые зачастую удобны при написании циклов.
	
	\subsection{Составные арифметические операции}
	
	Мы уже знаем, что для увеличения переменной x на 1 можно написать следующую инструкцию:
	
	\begin{lstlisting}
x = x + 1;
	\end{lstlisting}
	
	Увеличение переменной на 1 часто используется в циклах, поэтому для этой операции есть сокращённая запись:
	
	\begin{lstlisting}
++x;
	\end{lstlisting}
	
	\texttt{++} --- это оператор \textit{инкремента}. Точнее, приведённая выше запись --- это \textit{префиксный инкремент}. Также существует \textit{постфиксный инкремент}:
	
	\begin{lstlisting}
x++;
	\end{lstlisting}
	
	Они оба увеличивают значение переменной на $1$. 
	
	\note{Разница между префиксным и постфиксным инкрементом проявляется, если результат выполнения присвоить другой переменной. При использовании префиксного инкремента, значение новой переменной будет равно новому значению инкрементируемой, а при использовании постфиксного инкремента --- старому. Кроме того, префиксный инкремент работает быстрее постфиксного, хотя и несильно.}
	
	Существуют и другие составные операторы. Они приведены в таблице ниже:
	
	\tabularII{
		\hline
		\textbf{Сокращённая запись} & \textbf{Полная запись}\\
		\hline
		\texttt{a-{}-;} & \texttt{a = a - 1}\\
		\hline
		\texttt{a += b;} & \texttt{a = a + b;}\\
		\hline
		\texttt{a -= b;} & \texttt{a = a - b;}\\
		\hline
		\texttt{a *= b;} & \texttt{a = a * b;}\\
		\hline
		\texttt{a /= b;} & \texttt{a = a / b;}\\
		\hline
		\texttt{a \%= b;} & \texttt{a = a \% b;}\\
		\hline
	}
	
	\subsection{Цикл с предусловием (\texttt{while})}
	
	Рассмотрим самый простой из циклов --- цикл с предусловием (цикл \texttt{while} --- от англ. <<пока>>). Он имеет такой же синтаксис, как и \texttt{if} (в круглых скобках условие $A$, затем в фигурных скобках тело цикла $B$). Когда C++ выполняет этот блок кода, он поступает так:
	
	\begin{enumerate}
		\item{Если $A$ выполнено, сделать $B$.}
		\item{Если $A$ выполнено, сделать $B$.}
		\item{Если $A$ выполнено, сделать $B$.}
		
		\dots
	\end{enumerate}
	
	Как только условие перестаёт быть выполнено, C++ переходит к коду после цикла.
	
	Следующий код выводит числа от 1 до 5:
	
	\begin{lstlisting}
int i = 1;
while (i <= 5) {
	cout << i << endl;
	i++;
}
	\end{lstlisting}
	
	\style{Тело циклов (как этого, так и остальных) пишется с отступом на 4 пробела больше, чем у кода вне цикла.}
	
	\style{Наиболее распространённые названия переменных для счётчиков циклов --- $i$, $j$, $k$. От них ожидается такое предназначение, в отличие от $a$, $x$, $m$.}
	
	Один проход по телу цикла называется \textit{итерацией}.
	
	\subsection{Цикл <<$n$ раз>> (\texttt{for})}
	
	Рассмотрим тот же код, что и в прошлом примере. Оказывается, такие конструкции --- перебор чисел в каком-то диапазоне с фиксированным шагом --- встречаются довольно часто. Но при написании такой конструкции легко ошибиться, например, пропустить \texttt{i++}. Поэтому в языке C++ существует другой цикл, упрощающий такую конструкцию. Этот цикл называется \textit{циклом \texttt{for}}. Можно предположить, что это связано с его языковым аналогом <<\underline{для} каждого числа от ... до ... с шагом ... выполнить ...>>. Познакомимся с его синтаксисом:
	
	\begin{lstlisting}
for (A; B; C) {
	D;
}
	\end{lstlisting}
	
	$A$ содержит инструкцию, выполняемую до цикла один раз. Чаще всего, это инициализация счётчика.
	
	$B$ содержит условие, которое проверяется перед каждой итерацией. Если условие не выполняется, цикл завершается.
	
	$C$ содержит инструкцию, выполняемую после каждой итерации. Обычно это изменение счётчиков.
	
	$D$ --- тело цикла, то есть то, что выполняется на каждой итерации.
	
	Рассмотрим задачу:
	
	\task{Вводится число $n\ (1\le n\le 10^5)$. Выведите все натуральные числа от $1$ до $n$ (включительно).}
	
	Мы уже умеем решать эту задачу циклом \texttt{while}. Теперь решим её циклом \texttt{for}:
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cout << i << endl;
	}
}
	\end{lstlisting}
	
	Перед циклом мы создаём переменную $i$, изначально равную единице. Условие выполнения нашего цикла --- $i \le n$. После каждой итерации мы увеличиваем $i$ на 1. На каждой итерации мы выводим $i$.
	
	\note{Цикл \texttt{for} может быть заменён на \texttt{while} (выше текстом описано, как это сделать). Но это не является хорошим тоном, так как понижает читабельность кода.}
	
	\note{Некоторые части могут опускаться, например, ниже приведён корректный код:}
	
	\begin{lstlisting}
int i = 1;
for (; i <= 5; i++) {
	cout << i << endl;
}
	\end{lstlisting}
	
	\note{\texttt{for(;;)} --- бесконечный цикл, выполняющийся неограниченное число раз.}
	
	\subsection{Цикл с постусловием (\texttt{do-while})}
	
	Циклы \texttt{while} и \texttt{for} проверяют условие до выполнения цикла. Из этого следует, что если условие изначально ложно, то цикл не будет выполнен ни разу. Иногда это неудобно. Для этого создан цикл с постусловием. В отличие от цикла \texttt{while}, он выполняет следующее:
	
	\begin{enumerate}
		\item {Выполнить $B$.}
		\item {Если $A$, выполнить $B$.}
		\item {Если $A$, выполнить $B$.}
		\item {Если $A$, выполнить $B$.}
		
		\dots
	\end{enumerate}
	
	Таким образом, тело цикла \texttt{do-while} всегда выполняется хотя бы один раз.
	
	Познакомимся с синтаксисом этого цикла в C++:
	
	\begin{lstlisting}
do {
	B;
} while (A);
	\end{lstlisting}
	
	Условие проверяется после выполнения тела и записывается после него. Обратите внимание на \texttt{;} после условия.
	
	\section{Массивы}
	
	\subsection{Одномерные статические массивы}
	
	Часто в задачах возникает необходимость хранить некоторую последовательность значений довольно большой или заранее неизвестной длины. В таком случае применяются \textit{массивы}. Массив --- это упорядоченный набор значений одного типа. В этой главе мы познакомимся со статическими массивами. Динамические массивы будут разобраны позже.
	
	\note{Статические массивы --- <<наследие>> языка Си, предшественника C++.}
	
	Чтобы создать массив используется следующий синтаксис:
	
	\begin{lstlisting}
type name[size];
	\end{lstlisting}
	
	\texttt{type} --- это тип значений в массиве, \texttt{name} --- название переменной (имя массива), \texttt{size} --- размер массива, то есть количество значений, которое будет в нём храниться.
	
	Кроме того, элементам массива можно сразу присвоить значения:
	
	\begin{lstlisting}
int arr[5] = {1, 2, 3, 4, 5};
	\end{lstlisting}
	
	\underline{Обратите внимание}, что элементы массива перечисляются в фигурных скобках, в отличие от многих других языков программирования (Python, JavaScript).

	Чтобы заполнить массив нулями, можно использовать такой синтаксис:

	\begin{lstlisting}
int arr[5] = {0};
	\end{lstlisting}

	\important{Чтобы заполнить массив числами, отличными от нуля, нужно использовать цикл \texttt{for}.}
	
	Чтобы обращаться к элементам массива, используются квадратные скобки. Например, \texttt{arr[1]}.
	
	\important{Индексация (то есть нумерация элементов) массива начинается с \textbf{нуля}, а не с единицы. Поэтому если использовать приведённый выше массив, то \texttt{arr[0]} будет равно $1$, а \texttt{arr[1]} --- 2.}
	
	Массивы часто используется вместе с циклами. Например решим следующую задачу:
	
	\task{Дано число $n$, на следующей строке последовательность из $n$ чисел через пробел. Выведите эту последовательность в обратном порядке.}
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int n;
	cin >> n;
	int a[n];
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	for (int i = n - 1; i >= 0; i--) {
		cout << a[i] << ' ';
	}
}
	\end{lstlisting}
	
	\note{При работе со статическими массивами, их размер, согласно стандарту, требуется делать известным заранее (например, $10^5$). Несмотря на это, компилятор GCC допускает использование массивов так, как в приведённом выше примере.}$ $

	Написанный по стандарту код будет выглядеть так:

	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	const int ARRAY_SIZE = 1e5;
	int n;
	cin >> n;
	int a[ARRAY_SIZE];
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	for (int i = n - 1; i >= 0; i--) {
		cout << a[i] << ' ';
	}
}
	\end{lstlisting}

	\style{В случае использования констант, их следует объявлять как константы (так, как в приведённом выше примере).}

	\note{Выделение лишней памяти негативно сказывается на производительности. Но в задачах это не существенно, так как время и память оцениваются по наибольшим показателям среди всех тестов, а среди тестов обязательно встретится тест с максимальными ограничениями. Позже мы познакомимся с динамическим массивом (\texttt{vector}), который является более гибким.}
	
	\subsection{Двумерные массивы}
	
	Двумерные массивы служат для представления таблиц. Чтобы создать массив размера $n\times m$ требуется использовать \texttt{type name[n][m]} --- аналогично одномерным.

	Решим следующую задачу:

	\task{Даны числа $n$ и $m$ и массив целых чисел размера $n\times m$. Посчитайте сумму в каждой строке и в каждом столбце.}

	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	int n, m;
	cin >> n >> m;
	int arr[n][m];
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			cin >> arr[i][j];
		}
	}
	int sum_row[n];
	for (int i = 0; i < n; i++) {
		sum_row[i] = 0;
		for (int j = 0; j < m; j++) {
			sum_row[i] += arr[i][j];
		}
	}
	int sum_col[m];
	for (int i = 0; i < m; i++) {
		sum_col[i] = 0;
		for (int j = 0; j < n; j++) {
			sum_col[i] += arr[j][i];
		}
	}
	for (int i = 0; i < n; i++) {
		cout << sum_row[i] << ' ';
	}
	cout << '\n';
	for (int i = 0; i < m; i++) {
		cout << sum_col[i] << ' ';
	}
	cout << '\n';
}
	\end{lstlisting}
	
	\section{Символы. Строки.}
	
	\subsection{Символы}
	
	Раньше мы работали только с числами и массивами чисел. Теперь научимся работать с текстом. Познакомимся с новым типом данных C++ --- символ (\texttt{char}). По умолчанию C++ работает с символами по таблице ASCII (American Standard Code for Information Interchange) (читается [аски]), которые содержат только латинские буквы, цифры, знаки пунктуации и некоторые служебные символы (перевод строки, возврат каретки и т.д.). В таблице ASCII каждому символу сопоставлен номер от $0$ до $127$. Таким образом, номер символа можно хранить в 7 битах, но, из-за особенностей устройства памяти в компьютере, тип \texttt{char} занимает 1 байт (8 бит). Ниже приведена таблица ASCII:
	
	\begin{table}[H]
		\centering
		\begin{tabularx}{\textwidth}{|X|X||X|X||X|X||X|X||X|X||X|X|}
			\hline
			32 & пробел & 48 & 0 & 64 & @ & 80 & P & 96 & ` & 112 & p\\
			\hline
			33 & ! & 49 & 1 & 65 & A & 81 & Q & 97 & a & 113 & q\\
			\hline
			34 & " & 50 & 2 & 66 & B & 82 & R & 98 & b & 114 & r\\
			\hline
			35 & \# & 51 & 3 & 67 & C & 83 & S & 99 & c & 115 & s\\
			\hline
			36 & \$ & 52 & 4 & 68 & D & 84 & T & 100 & d & 116 & t\\
			\hline
			37 & \% & 53 & 5 & 69 & E & 85 & U & 101 & e & 117 & u\\
			\hline
			38 & \& & 54 & 6 & 70 & F & 86 & V & 102 & f & 118 & v\\
			\hline
			39 & ' & 55 & 7 & 71 & G & 87 & W & 103 & g & 119 & w\\
			\hline
			40 & ( & 56 & 8 & 72 & H & 88 & X & 104 & h & 120 & x\\
			\hline
			41 & ) & 57 & 9 & 73 & I & 89 & Y & 105 & i & 121 & y\\
			\hline
			42 & * & 58 & : & 74 & J & 90 & Z & 106 & j & 122 & z\\
			\hline
			43 & + & 59 & ; & 75 & K & 91 & [ & 107 & k & 123 & \{\\
			\hline
			44 & , & 60 & < & 76 & L & 92 & | & 108 & l & 124 & |\\
			\hline
			45 & - & 61 & = & 77 & M & 93 & ] & 109 & m & 125 & \}\\
			\hline
			46 & . & 62 & > & 78 & N & 94 & \textasciicircum & 110 & n & 126 & \textasciitilde\\
			\hline
			47 & / & 63 & ? & 79 & O & 95 & \_ & 111 & o & & \\
			\hline
		\end{tabularx}
	\end{table}
	
	Символы до \textnumero$31$ все являются служебными.
	
	Значения этого типа пишутся в одинарных кавычках, например,
	
	\begin{lstlisting}
char c = 'x';
	\end{lstlisting}
	
	Выведем $c$ на экран. На экране мы увидим символ \texttt{x}. Теперь рассмотрим следующий код:
	
	\begin{lstlisting}
char c = 'x';
int a = c;
cout << a;
	\end{lstlisting}
	
	На экране мы увидим число $120$ --- номер символа \texttt{x}.
	
	\subsubsection{Арифметические операции с символами}
	
	Благодаря тому, что символам сопоставлены числа, мы можем работать с ними, как с числами. Рассмотрим следующий пример:
	
	\task{Дан символ, являющийся строчной буквой латинского алфавита. Определить его номер в алфавите (считая, что букве \texttt{a} соответствует номер 1).}
	
	Вычтем из данного нам символа символ \texttt{a}. Тогда мы узнаем номер символа в $0$-индексации. Добавим 1, чтобы получить его в $1$-индексации.
	
	\begin{lstlisting}
char c;
cin >> c;
cout << c - 'a' + 1;
	\end{lstlisting}
	
	Другой пример:
	
	\task{Дано число $x$. Выведите $x$-ю строчную букву латинского алфавита.}
	
	Теперь нам нужно решить задачу, обратную предыдущей. Напишем такой код:
	
	\begin{lstlisting}
int x;
cin >> x;
cout << 'a' + (x - 1);
	\end{lstlisting}
	
	Запустим его. Введём, например, $5$. На экране мы увидим $101$. Это связано с тем, что результат арифметических действий над символами вычисляется в типе \texttt{int}. Чтобы исправить это, изменим код так:
	
	\begin{lstlisting}
int x;
cin >> x;
cout << (char)('a' + (x - 1));
	\end{lstlisting}
	
	Теперь код, как и должно быть, выводит \texttt{e}. Мы явно указали C++, что требуется \textit{привести} тип \texttt{int} к типу \texttt{char}.
	
	\exercise{Вводится символ, являющийся цифрой. Считайте его \underline{как символ}, а затем преобразуйте к соответствующему числу (в тип \texttt{int}).}
	
	\subsubsection{Логические операторы}
	
	С символами определены и операторы сравнения ($>$, $<$ и т.д.). Символы сравниваются в порядке номеров в таблице ASCII. Наиболее часто пригождается проверка, является ли символ буквой (строчной буквой, заглавной буквой, цифрой и т.д.).
	
	Так как строчные буквы (как и заглавные буквы и цифры) идут в таблице ASCII последовательно, для этого достаточно сравнить символы. Например, так:
	
	\begin{lstlisting}
char c;
cin >> c;
if ('A' <= c && c <= 'Z') {
	cout << "YES";
} else {
	cout << "NO";
}
	\end{lstlisting}

	\subsection{Строки}

	\textit{Строкой} в программировании называется любая последовательность символов. Для хранения строк используется тип \texttt{string}. Для него определён ввод и вывод (через \texttt{>{}>} и \texttt{<{}<} соответственно). Для обращения к номерам символов используется такой же синтаксис, как и у массивов, --- квадратные скобки.

	\important{Нумерация символов в строке начинается с $0$.}

	Кроме того, для скобок определен оператор \texttt{+}, который выполняет \textit{конкатенацию} строк, то есть их <<склеивание>>. Кроме того, для строк определён \textit{метод} \texttt{substr}, который позволяет получить \textit{подстроку} (то есть непрерывный участок исходной строки). 
	
	Первое число указывает индекс начала строки, второе число --- длину подстроки. Если второе число не указано, то конец подстроки совпадает с концом строки. Познакомимся с методом \texttt{substr} на примере:

	\begin{lstlisting}
string s = "abcdef";
s.substr(1, 3); // "bcd"
s.substr(2); // "cdef"
	\end{lstlisting}
	
	Строки можно вводить аналогично числам (\texttt{cin >> string\_name}), но этот способ читает строку до пробела, не включая пробел. При этом пробел будет пропущен, то есть не будет получен при следующем чтении. В случае, если нужно считать строку целиком, можно использовать функцию \texttt{getline}. Её синтаксис таков:
	
	\begin{lstlisting}
string string_name;
getline(cin, string_name);
	\end{lstlisting}
	
	Есть и другой способ считывания строки с пробелами: выполнять считывание, пока не закончится файл входных данных (для тестирования у себя на компьютере используйте \texttt{Ctrl+D}, затем \texttt{Enter} для завершения ввода). Стандартная реализация выглядит так:
	
	\begin{lstlisting}
string word;
while (cin >> word) {
	
}
	\end{lstlisting}
	
	В теле цикла обрабатывают очередное слово.
	
	Так можно поступать и с последовательностями чисел неизвестной длины.
	
	Отметим, что существуют функции \texttt{to\_string} и \texttt{stoi} (от \texttt{string to int}), которые преобразуют целое число в строку и наоборот.

	\section{Процедуры. Функции. Рекурсия.}

	Циклы помогли нам избежать повторов аналогичного кода. Отсутствие повторов --- это хорошо, потому что:
	
	\begin{enumerate}
		\item {Код меньше.}
		\item {Если была допущена ошибка, её надо исправить только в одном месте.}
	\end{enumerate}
	
	Функции --- это ещё один способ избавиться от повторов.
	
	\subsection{Процедуры}
	
	Разберём несколько задач, чтобы понять, что такое процедура.
	
	\task{Три раза повторите следующее: считайте строку $s$ и выведите <<\texttt{Hello, }>>, а затем строку $s$.}
	
	Выделим повторяющуюся часть кода. Здесь это чтение строки $s$ и вывод приветствия. Выделим это в отдельный <<блок кода>>, назовём его \texttt{hello}:
	
	\begin{lstlisting}
#include <iostream>
#include <string>

using namespace std;

void hello() {
	string s;
	cin >> s;
	cout << "Hello, " << s << '\n';
}

int main() {
	for (int i = 0; i < 3; i++) {
		hello();
	}
}
	\end{lstlisting}
	
	Мы определили процедуру \texttt{hello}. Внутри фигурных скобок написано то, что она делает. Чтобы \textit{вызвать} (выполнить) её, нужно написать её имя (в данном случае, \texttt{hello}), а затем круглые скобки, что мы и делаем в цикле.
	
	\task{Дано число $n$. Вывести $n$ строк, в $i$-й строке вывести $i$ символов <<*>>.}
	
	Попробуем найти в задаче повторяющийся алгоритм. В данном случае, это вывод некоторого количества звёздочек в строку, но их количество отличается. Теперь у алгоритма появился \textit{параметр} --- количество звёздочек. Поэтому мы можем создать процедуру, которая будет \textit{принимать} параметр $x$ и печатать $x$ звёздочек. В основном коде мы $n$ раз \textit{вызовем} (выполним) эту процедуру для каждого $x$ от $1$ до $n$. В коде это будет выглядеть так:
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

void printStars(int x) {
	for (int i = 0; i < x; i++) {
		cout << '*';
	}
	cout << '\n';
}

int main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		printStars(i);
	}
}
	\end{lstlisting}
	
	Для каждого параметра указывается его тип и название, параметры перечисляются через запятую.

	\subsection{Функции}

	Процедуры умеют совершать аналогичные действия для разных параметров. Но часто требуется, чтобы функция, как в математике, <<выдавала>> (\textit{возвращала}) некоторый результат.

	Функции определяются так же, как и процедуры, но вместо \texttt{void} указывается тип того значения, которое возвращает функция. Процедуры обычно тоже считаются функциями.

	Пусть нам нужна функция, которая вычисляет длину гипотенузы по двум катетам. Тогда она принимает два вещественных числа, длины катетов, и возвращает одно вещественное число --- длину гипотенузы. Эта функция будет выглядеть так:

	\begin{lstlisting}
long double hyp(long double a, long double b) {
	return sqrt(a * a + b * b);
}
	\end{lstlisting}

	Обратите внимание на ключевое слово \texttt{return}. После него следует то значение, которое возвращает функция.
	
	\note{Функция, аналогичная нашей \texttt{hyp}, определена в библиотеке \texttt{cmath} и называется \texttt{hypot}.}

	Кроме того, следует заметить, что \texttt{sqrt}, \texttt{abs} и т.п. --- тоже функции, но они определены не нами, а авторами библиотеки \texttt{cmath}.
	
	\note{Безусловно, примеры, приведённые в этой главе довольно надуманы. Несмотря на это, функции являются очень важными при написании крупного кода. Кроме того, скоро мы познакомимся с рекурсией, использование которой часто помогает написать более простой код.}
	
	\important{Пожалуйста, при решении задач по теме <<Функции>> не выносите весь код, кроме ввода и вывода, из \texttt{main} в отдельную функцию! Попробуйте выделить повторяющееся действие и применить реализованную функцию несколько раз.}
	
	\note{Названия функций должно удовлетворять тем же требованиям, что и имена переменных.}
	
	\style{Функциям следует давать имена, соответствующие их назначению.}
	
	\subsection{Снова об области видимости. Глобальные переменные}
	
	В пункте 2.3.1 мы говорили об области видимости переменных. В частности, переменные, объявленные в функции доступны только в ней. Чтобы переменные были доступны во всех функциях, их надо объявить в \textit{глобальной области}, например, так:
	
	\begin{lstlisting}
#include<iostream>

using namespace std;

int a;

int func() {
	cout << a * a;
}

int main() {
	cin >> a;
	func();
}
	\end{lstlisting}
	
	\style{В промышленной разработке использование глобальных переменных является плохим стилем, но в олимпиадном программирование они скорее приветствуются.}
		
	\subsection{Передача массива в функцию}
	
	Чтобы передать статический массив в функцию, надо указать звёздочку после типа, который хранится в этом массиве. Обычно следующим параметром передаётся длина массива. Например, напишем функцию, вычисляющую сумму чисел в массиве:
	
	\begin{lstlisting}
int countSum(int* a, int n) {
	int sum = 0;
	for (int i = 0; i < n; i++) {
		sum += a[i];	
	}
	return sum;
}
	\end{lstlisting}
	
	Следует отметить, что в примере выше \texttt{a} --- это \textit{указатель} на тип \texttt{int}, но указатели выходят за рамки программы 8 класса.
	
	\subsection{Передача значений по ссылке}
	
	Проверим, копирует ли C++ значения при передаче их в функцию, то есть меняется ли значение переменных, переданных в функцию, если изменить их в функции. Для этого напишем следующий код:
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

void func(int x) {
	x++;
	cout << x << '\n'; // 6
}

int main() {
	int x = 5;
	func(x);
	cout << x << '\n'; // 5
}
	\end{lstlisting}
	
	Таким образом, \underline{C++ создаёт копии элементов при их передаче в функцию}. Очень важно помнить об этом по двум причинам:
	
	\begin{enumerate}
		\item{Иногда хочется, чтобы C++ не создавал копии, а передавал именно те же объекты. О том, как это сделать мы поговорим ниже.}
		\item{В случае передачи <<тяжёлых>> объектов (например, векторов, с которыми мы познакомимся позже) функция может работать быстрее, чем копирование массива, которое бывает необязательным. Всегда передавайте векторы по ссылке, если это возможно.}
	\end{enumerate}
	
	Чтобы передать в функцию объект без копирования, после типа данных надо поставить амперсанд (\texttt{\&}), например:
	
	\begin{lstlisting}
#include <iostream>

using namespace std;

void func(int& x) {
	x++;
	cout << x << '\n'; // 6
}

int main() {
	int x = 5;
	func(x);
	cout << x << '\n'; // 6
}
	\end{lstlisting}

	\subsection{О \texttt{main}}

	Теперь посмотрим на \texttt{main}. По синтаксису это функция, которая возвращает целое число, но ничего не принимает. Обратите внимание, что нами эта функция нигде явно не вызывается. Но почему же она возвращает целое число? И почему мы не используем \texttt{return}?

	На самом деле, функция \texttt{main} возвращает то значение, которое возвращает программа. Обычно мы нигде не сталкиваемся с возвращаемым значением программ. Оно используется, чтобы указать, что программа завершилась без ошибок или с какой ошибкой завершилась программа. Если программа завершилась без ошибок, то возвращаемое значение должно быть равно $0$. Иначе оно должно быть отлично от $0$.

	Большинство наиболее популярных компиляторов сами добавляют \texttt{return 0;} в конец функции \texttt{main}.

	\important{Если функция \texttt{main} будет возвращать значение, отличное от $0$, программа в тестирующей системе получит вердикт \texttt{Ошибка исполнения}.}

	\subsection{Рекурсия}

	Давайте попробуем вычислить факториал числа ($n!=1\cdot2\cdot\dots n$, $0!=1$). Мы можем написать решение, использующее циклы, но теперь попробуем написать другое решение.
	
	Заметим, что $n!=n \cdot (n-1)!$. Тогда мы можем написать такой код:
	
	\begin{lstlisting}
int fact(int n) {
	if (n == 0) return 1;
	return n * fact(n - 1);
}
	\end{lstlisting}
	
	Мы пользуемся приведённом выше свойством, чтобы вычислить значение функции-факториала \textit{рекурсивно}: функция вызывает саму себя.
	
	При написании рекурсивных функций важно помнить о \textit{базовом случае} --- условии, при котором не происходит рекурсивного вызова, так как, если бы его не было, рекурсия была бесконечной. В нашей функции базовый случай --- $n=0$.
	
	Теперь попробуем научиться вычислять $n$-й член последовательности Фибоначчи, которая задаётся рекуррентно.

	$$F_0=0, F_1=1, F_n = F_{n-2}+F_{n-1}\ (n \ge 2)$$

	Реализация приведена ниже:

	\begin{lstlisting}
int fib(int n) {
	if (n == 0) return 0;
	if (n == 1) return 1;
	return fib(n - 1) + fib(n - 2);
}
	\end{lstlisting}
	
	Теперь у нас $2$ базовых случая ($n=0$ и $n=1$). Так тоже бывает.
	
	\note{Данный код крайне не эффективен, так как мы многократно вычисляем значение для одного и того же числа. Для оптимизации можно применить технику \textit{мемоизации} --- запоминать уже вычисленные значения. Например, если мы знаем, что значение $n$ не будет превосходить $50$, то можно использовать следующий код:}
	
	\begin{lstlisting}
const int N = 51;
int mem[N];

int fib(int n) {
	if (mem[n] != -1) return mem[n];
	if (n == 1 || n == 2) {
		return mem[n] = 1;
	}
	return mem[n] = fib(n - 1) + fib(n - 2);
}

int main() {
	for (int i = 0; i < N; i++) {
		mem[i] = -1;
	}
	int n;
	cin >> n;
	cout << fib(n) << '\n';
}
	\end{lstlisting}
	
	В приведённом выше коде мы запоминаем уже вычисленные значения в массиве \texttt{mem}, используя $-1$ как метку, что значение ещё не было вычислено. Массив имеет длину на $1$ большую, чем максимальное число, которое может быть передано в функцию, так как индексация массива начинается с $0$.
	
	Обратите внимание, что мы можем возвращать результат присваивания. В таком случае, будет возвращено присвоенное значение.
	
	\section{Структуры данных}
	
	Мы уже знакомы со статическими массивами. Теперь изучим векторы и пары --- важные структуры данных, встроенные в C++. После них мы познакомимся со структурами, которые позволяют объединять в один тип любые комбинации других типов, определять для них операторы и т.д.
	
	\subsection{Векторы (динамические массивы)}
	
	Ранее мы уже познакомились со статическими массивами, длина которых задана заранее и не изменяется. Теперь познакомимся с векторами.
	
	Чтобы работать с векторами, требуется подключить библиотеку \texttt{vector}. Чтобы создать вектор, нужно написать
	
	\begin{center}
		\texttt{vector<Type> name;},
	\end{center}
	
	где \texttt{Type} --- тип содержимого (например, \texttt{bool}), а \texttt{name} --- имя переменной-вектора. Вектору можно сразу присвоить значение, например,
	
	\begin{lstlisting}
vector<int> a = {1, 2, 3};
	\end{lstlisting}
	
	Другой способ создать вектор --- указать количество элементов и их значение. Приведённая ниже строка создаёт вектор из пяти элементов, каждый из которых равен $-1$.
	
	\begin{lstlisting}
vector<int> a(5, -1);
	\end{lstlisting}
	
	Можно указать только количество элементов, тогда вектор будет заполнен <<стандартными>> значениями данного типа ($0$ для чисел, пустая строка для строк и т.д.):
	
	\begin{lstlisting}
vector<int> a(5);
	\end{lstlisting}
	
	\important{Длина вектора указывается в круглых скобках. Если вы попробуете использовать квадратные скобки, то вы создадите статический массив, элементы которого --- векторы.}
	
	Обращение к элементам вектора по индексу осуществляется через квадратные скобки, так же, как и со статическими массивами. Индексация тоже \underline{начинается с нуля}.
	
	Теперь поговорим о возможностях вектора, которых нет у статических массивов. Самая примечательная особенность --- возможность добавлять в конец или удалять последний элемент. Для этого используются \textit{методы} \texttt{push\_back} и \texttt{pop\_back}.
	
	\textit{Метод} --- это функция, относящаяся к определённому объекту. Чтобы вызвать метод, нужно написать имя объекта (в данном случае --- имя переменной-вектора), через точку название метода, затем в круглых скобках через запятую аргументы.
	
	Познакомимся с методами и их синтаксисом на примере:
	
	\begin{lstlisting}
vector<int> a = {1, 2, 3};
a.push_back(4); // a = {1, 2, 3, 4}
a.pop_back(); // a = {1, 2, 3}
a.pop_back(); // a = {1, 2}
	\end{lstlisting}
	
	Так как размер вектора может меняться, то мы можем узнать текущий размер массива. Для этого используется метод \texttt{size}:
	
	\begin{lstlisting}
vector<int> a = {1, 2, 3};
a.pop_back();
a.size(); // 2
	\end{lstlisting}
	
	Ещё одна особенность вектора --- возможность перебирать его не только с помощью перебора индекса, но и \textit{с помощью \texttt{for-auto}}. Например, приведённый ниже код выводит \texttt{54 5 4}.
	
	\begin{lstlisting}
vector<int> a = {54, 5, 4};
for (auto& i : a) {
	cout << i << ' ';
}
	\end{lstlisting}
	
	Часто такой перебор вектора используется для считывания массива. Например,
	
	\begin{lstlisting}
int n;
cin >> n;
vector<int> a(n);
for (auto& i : a) {
	cin >> i;
}
	\end{lstlisting}
	
	Этот код считывает сначала длину массива, а затем все его элементы.
	
	Кроме возможности вставки в конец (\texttt{push\_back}) и удаления из конца (\texttt{pop\_back}), вектор может осуществлять вставку <<в середину>> (в произвольное место в массиве) и удаление <<из середины>>. Рассмотрим пример. Возьмем массив \texttt{\{1, 2, 3\}}. Совершим с ним следующие операции:
	
	\begin{enumerate}
		\item{Вставим элемент $4$ по индексу $2$. \textleftarrow \texttt{\{1, 2, 4, 3\}}.}
		\item{Удалим элемент по индексу $1$. \textleftarrow \texttt{\{1, 4, 3\}}}
	\end{enumerate}
	
	\begin{lstlisting}
vector<int> a = {1, 2, 3};
a.insert(a.begin() + 2, 4);
a.erase(a.begin() + 1);
	\end{lstlisting}
	
	Методы \texttt{insert} и \texttt{erase} работают с \textit{итераторами}, т.е. с особым типом данных, который указывает на определённое место в памяти. \texttt{begin} --- итератор, указывающий на начало. Прибавив к нему $i$, мы получим итератор, указывающий на $i$-й элемент вектора, т.к. элементы вектора хранятся в памяти последовательно.
	
	\important{Операции \texttt{push\_back} и \texttt{pop\_back} осуществляют количество операций порядка $1$, а \texttt{insert} и \texttt{erase} --- порядка длины вектора, т.е. выполняются существенно дольше.}
	
	\subsection{Двумерные векторы}
	
	В векторах можно хранить другие векторы. Например,
	
	\begin{lstlisting}
vector<vector<int>> a = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
	\end{lstlisting}
	
	Обратите внимание, что для создания двумерного вектора заданного размера ($n\times m$) правильно писать так:
	
	\begin{lstlisting}
vector<vector<int>> a(n, vector<int>(m));
vector<vector<int>> b(n, vector<int>(m, 54));
	\end{lstlisting}
	
	Двумерный вектор \texttt{b} имеет размер $n\times m$ и заполнен числами $54$.
	
	\subsection{Пара (\texttt{pair})}
	\label{sec:pair}
	
	Пара используется для хранения в одной переменной двух значений разных типов. Чтобы создать пару, используется следующий синтаксис:
	
	\begin{center}
		\texttt{pair<Type1, Type2> name;}
	\end{center}
	
	Например,
	
	\begin{lstlisting}
pair<int, string> a = {54, "School No. 54"};
	\end{lstlisting}
	
	В паре можно хранить и одинаковые значения. В том числе пары часто хранятся в векторах вместо использования двумерных массивов, одна из размерностей которого --- $2$.
	
	Чтобы обратиться к элементам пары, используются \textit{свойства \texttt{first} и \texttt{second}}. Обращение к свойствам, как и к методам, осуществляется через точку, но после названия свойства не ставятся скобки.
	
	\subsection{Структуры (\texttt{struct})}
	
	Чтобы объявить структуру, используется следующий синтаксис:
	
	\begin{lstlisting}
struct TypeName {
	Type1 name1;
	Type2 name2;
	...
	TypeN nameN;
};
	\end{lstlisting}
	
	\important{После объявления структуры ставится точка с запятой.}
	
	Например, пусть нам надо хранить информацию о клетке, у которой есть две целых координаты (\texttt{x} и \texttt{y}) и прочность (\texttt{durability}) --- дробное число.
	
	\begin{lstlisting}
struct Cell {
	int x, y;
	double durability;
};
	\end{lstlisting}
	
	Тогда, чтобы создать переменную, хранящую информацию о клетке с координатами $(54, -54)$ и прочностью $5.4$, используется следующий синтаксис:
	
	\begin{lstlisting}
Cell x = {54, -54, 5.4};
	\end{lstlisting}
	
	Поля в фигурных скобках перечисляются в том же порядке, что и при объявлении структуры.
	
	Чтобы обратиться к свойству структуры, имя свойства пишут через точку после имени переменной. Например,
	
	\begin{lstlisting}
x.durability; // 5.4
x.x; // 54
x.y; // -54
	\end{lstlisting}
	
	\subsubsection{Переопределение операторов}
	
	Рассмотрим следующую задачу:
	
	\task{Реализуйте структуру \texttt{Point}, содержащую две целых координаты. Реализуйте возможность сложения двух точек (оператором \texttt{+}). У точки-суммы каждая координата равна сумме соответствующих координат точек-операндов.}
	
	Решение приведено ниже:
	
	\begin{lstlisting}
struct Point {
	int x, y;
};

Point operator+(Point a, Point b) {
	return {a.x + b.x, a.y + b.y};
}
	\end{lstlisting}
	
	Таким образом, чтобы \textit{переопределить оператор}, надо объявить специальную функцию --- \texttt{operator+} (существуют аналогичные названия для большинства остальных операторов).
	
	Теперь реализуем возможность ввода и вывода нашей структуры. Для этого переопределим операторы \texttt{<{}<} и \texttt{>{}>}:
	
	\begin{lstlisting}
istream& operator>>(istream& stream, Point& p) {
	stream >> p.x >> p.y;
	return stream;
}

ostream& operator<<(ostream& stream, Point& p) {
	stream << p.x << ' ' << p.y;
	return stream;
}
	\end{lstlisting}
	
	Обратите внимание, что надо возвращать сам поток, чтобы можно было считывать несколько значений одной инструкцией.
	
	\section{Графы}
	
	\subsection{Основные определения}
	\label{sec:graph-main-def}
	
	\textit{Граф} --- это множество \textit{вершин} и \textit{рёбер} --- пар вершин.
	
	Вершины графа часто изображают в виде кругов, а рёбра --- как отрезки между ними, как на рисунке ниже:
	
	\begin{center}
		\includegraphics[height=5cm]{graph}
	\end{center}
	
	\textit{Степенью} вершины называется количество рёбер с концом в этой вершине.
	
	Два ребра называются \textit{кратными}, если оба их конца совпадают.
	
	Ребро называют \textit{петлёй}, если оно соединяет вершину с самой собой.
	
	\subsection{Способы хранения графов}
	
	В программировании часто возникает необходимость хранить графы и обрабатывать их.
	
	При описании способов хранения и их преимуществ будем обозначать число вершин в графе $n$, а число рёбер --- $m$.
	
	В качестве примера для каждого типа опишем, как сохранить граф из п. \ref*{sec:graph-main-def}.
	
	\subsubsection{Список рёбер}
	
	В этом, как и во всех последующих способах, пронумеруем вершины в некотором порядке. Тогда мы можем просто хранить массив пар\footnote{Про тип \texttt{pair} см. раздел \ref*{sec:pair}} рёбер.
	
	Пример: \texttt{\{\{1, 2\}, \{1, 5\}, \{2, 5\}, \{2, 3\}, \{3, 5\}, \{2, 4\}\}}
	
	\subsubsection{Матрица смежности}
	
	Рассмотрим таблицу $n\times n$. В $i$-й строке $j$-м столбце поставим $1$, если между вершинами $i$ и $j$ есть ребро, и $0$ иначе.
	
	Пример:
	
	\begin{tabular}{|c||c|c|c|c|c|}
		\hline
		& 1 & 2 & 3 & 4 & 5 \\
		\hline
		\hline
		1 & 0 & 1 & 0 & 0 & 1 \\
		\hline
		2 & 1 & 0 & 1 & 1 & 1 \\
		\hline
		3 & 0 & 1 & 0 & 0 & 1 \\
		\hline
		4 & 0 & 1 & 0 & 0 & 0 \\
		\hline
		5 & 1 & 1 & 1 & 0 & 0 \\
		\hline
	\end{tabular}
	
	\subsubsection{Список смежности}
	
	Создадим двумерный список $g$. В $g[v]$ запишем все номера вершин, с которыми $v$ связана ребром.
	
	Пример:\\
	\texttt{
	1: \{2, 5\}\\
	2: \{1, 3, 4, 5\} \\
	3: \{2, 5\} \\
	4: \{2\} \\
	5: \{1, 2, 3\} \\
	}
	
	\subsection{Сравнение всех методов хранения графов}
	
	Сравнение приведём в виде таблицы:
	
	\begin{table}[H]
		\centering
		\begin{tabularx}{\textwidth}{|X|X|X|X|}
			\hline
			\textbf{Критерий} & \textbf{Список рёбер} & \textbf{Матрица смежности} & \textbf{Список смежности} \\
			\hline
			\textbf{Занимаемая память (с точностью до константы)} & $m$ & $n^2$ & $m$ (\footnotemark) \\
			\hline
			\textbf{Проверка наличия ребра} & $m$ & $1$ & $n$ (\footnotemark) \\
			\hline
			\textbf{Перебор всех соседей вершины} & $m$ & $n$ & $n$ (\footnotemark) \\
			\hline
		\end{tabularx}
	\end{table}
	
	\footnotetext[2]{Сумма степеней вершин в графе равна удвоенному количеству рёбер, т.к. у каждого ребра два конца. Поэтому наш массив занимает $2m$ памяти.}
	\footnotetext[3]{В худшем случае, который достигается, если вершина соединена со всеми остальными. Время работы можно уменьшить, если использовать \texttt{set} или \texttt{unordered\_set}}
	\footnotetext[4]{В худшем случае. Если у вершины $k$ соседей, то их можно перебрать за $k$ операций.}
	
	\subsection{А если граф ориентированный?}
	
	Ранее мы рассматривали \textit{неориентированные} графы --- такие графы, что если проведено ребро $u \rightsquigarrow v$, то проведено и ребро $v \rightsquigarrow u$.
	
	Но бывает и по-другому, например, как-то так:
	
	\begin{center}
		\includegraphics[height=5cm]{or-graph}
	\end{center}
	
	Оказывается, что все три наших способа хранения вполне выдерживают такое изменение. Представим изображённый выше граф всеми тремя способами:
	
	\begin{itemize}
		\item \textbf{Список рёбер}
		\texttt{\\\{\\
		\{1, 2\},\\
		\{1, 5\},\\
		\{5, 3\},\\
		\{3, 2\},\\
		\{4, 2\},\\
		\{2, 5\},\\
		\{5, 2\}\\
		\}}
		
		\item \textbf{Матрица смежности}
		
		Договоримся, что индекс строки --- это номер начала ребра, а индекс столбца --- номер конца ребра.
		
		\begin{tabular}{|c||c|c|c|c|c|}
			\hline
			& 1 & 2 & 3 & 4 & 5 \\
			\hline
			\hline
			1 & 0 & 1 & 0 & 0 & 1 \\
			\hline
			2 & 0 & 0 & 0 & 0 & 1 \\
			\hline
			3 & 0 & 1 & 0 & 0 & 0 \\
			\hline
			4 & 0 & 1 & 0 & 0 & 0 \\
			\hline
			5 & 0 & 1 & 1 & 0 & 0 \\
			\hline
		\end{tabular}
		
		\important{У неориентированного графа матрица смежности симметрична относительно главной диагонали, у ориентированного --- не всегда.}
		
		\item \textbf{Список смежности}
		
		\texttt{\\
			1: \{2, 5\}\\
			2: \{5\} \\
			3: \{2\} \\
			4: \{2\} \\
			5: \{2, 3\} \\
		}
	\end{itemize}
	
	Введём ещё несколько определений, применимых только к ориентированным графам:
	
	\textit{Полустепенью захода} вершины называется количество рёбер, которые заканчиваются в этой вершине.
	
	Аналогично, \textit{полустепенью исхода} вершины называется количество рёбер, которые начинаются в этой вершине.
	
	\textit{Истоком} называется вершина, чья полустепень захода равна нулю. (Т.е. из неё рёбра только выходят.)
	
	\textit{Стоком} называется вершина, чья полустепень исхода равна нулю. (Т.е. в неё рёбра только входят.)
	
	\subsection{А если граф содержит петли или кратные рёбра?}
	
	Если в графе есть кратные рёбра, то список рёбер и список смежности продолжают работать хорошо. С матрицей смежности тяжелее, но можно хранить не только факт наличия или отсутствия ребра (\texttt{0}/\texttt{1}), а их количество, но обычно это число используется с другими целями, о чём мы поговорим в следующем разделе.
	
	Если в графе есть петли, то все способы хранения графов продолжают работать.
	
	\subsection{А если граф взвешенный?}
	
	Граф называется \textit{взвешенным}, если на рёбрах <<написаны>> числа\footnote{Формально: определена функция $E\to\mathbb{R}$, где $E$ --- множество рёбер, которая по ребру выдаёт число.}. Число, написанное на ребре, называется \textit{весом} ребра.
	
	В таком случае, чтобы сохранить граф списком рёбер, будем хранить уже не пары, а тройки чисел\footnote{Для этого можно создать структуру ребра или использовать вектор. Второй вариант проще, но предпочтительнее первый.} --- индексы начала и конца ребра и его вес.
	
	Чтобы сохранить граф матрицей смежности, в клетках запишем вес ребра, если оно есть, и какое-нибудь число $c$, которое будет обозначать его отсутствие. При этом для однозначности $c$ должно быть таким, чтобы оно не было возможным весом ребра. Если веса рёбер положительны, то можно взять $c = 0$ или $c=-1$. Если веса рёбер могут быть отрицательными, то можно взять очень большое или очень маленькое число.
	
	% Пример?
	
	\section{Введение в теорию чисел}
	
	% Где этот раздел расположить?
	
	\subsection{Проверка на простоту}
	
	Натуральное число называется \textit{простым} (англ. \texttt{prime}), если оно имеет только два натуральных делителя: $1$ и само себя. Научимся проверять число на простоту.
	
	Самый простой код, который можно написать, приведён ниже. Мы перебираем все числа от $2$ до $n - 1$ и проверяем, являются ли они делителями.
	
	\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
	int n;
	cin >> n;
	if (n == 1) {
		cout << "NO";
		return 0;
	}
	bool is_prime = true;
	for (int i = 2; i < n; i++) {
		if (n % i == 0) {
			is_prime = false;
		}
	}
	if (is_prime) {
		cout << "YES";
	} else {
		cout << "NO";
	}
}
	\end{lstlisting}
	
	\stat{Если $k$ --- делитель $n$, то $\frac{n}{k}$ --- тоже делитель $n$.}
	
	\textbf{Доказательство}. Если $k$ --- делитель $n$, то для некоторого целого $q$
	
	$$ n = kq $$
	
	Тогда $q = \frac{n}{k}$, значит,
	
	$$ n = k \cdot \frac{n}{k} $$
	
	А значит, по определению делимости $\frac{n}{k}$ --- делитель $n$. $\blacksquare$
	
	Тогда можно заметить, что числа от $\frac{n}{2}$ до $n$ (обе границы невключительно) не могут быть делителями, т.к. тогда бы некоторое число от $1$ до $2$ (невключительно) было бы делителем $n$, что невозможно.
	
	Тогда мы можем ускорить наш код примерно в два раза, изменив границу в цикле:
	
	\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
	int n;
	cin >> n;
	if (n == 1) {
		cout << "NO";
		return 0;
	}
	bool is_prime = true;
	for (int i = 2; i <= n / 2; i++) {
		if (n % i == 0) {
			is_prime = false;
		}
	}
	if (is_prime) {
		cout << "YES";
	} else {
		cout << "NO";
	}
}
	\end{lstlisting}
	
	Теперь сделаем наблюдение, которые значительно ускорит наш код:
	
	\stat{Если у $n$ нет делителей, таких что $2 \le k \le \sqrt{n}$ (\footnote{Иными словами, $k^2 \le n$}), то $n$ --- простое число.}
	
	\textbf{Доказательство}. От противного. Пусть $n$ не является простым. Тогда у $n$ есть делитель $m$, т.ч. $m^2 > n\ (*)$ и $m < n$. Но тогда по утверждению, доказанному выше, $\frac{n}{m}$ --- тоже делитель $n$.
	
	Тогда, т.к. все делители в квадрате превосходят $n$, то $\left(\frac{n}{m}\right)^2 > n\ (**)$.
	
	Перемножим неравенства $(*)$ и $(**)$: $m^2 \cdot \left(\frac{n}{m}\right)^2 > n^2$. Тогда: $$ n^2 > n^2 $$ Противоречие. $\blacksquare$
	
	Значит, достаточно проверить только такие числа, что их квадрат не превосходит $n$.
	
	\begin{lstlisting}
#include <iostream>
using namespace std;
int main() {
	int n;
	cin >> n;
	if (n == 1) {
		cout << "NO";
		return 0;
	}
	bool is_prime = true;
	for (int i = 2; i * i <= n; i++) {
		if (n % i == 0) {
			is_prime = false;
		}
	}
	if (is_prime) {
		cout << "YES";
	} else {
		cout << "NO";
	}
}
	\end{lstlisting}
	
	\important{\textbf{Не} проверяйте описанное выше условие на \texttt{i} через функцию \texttt{sqrt}, так как она работает в дробных числах.}
	
	\subsection{Решето Эратосфена}
	
	\subsection{Алгоритм Евклида}
	
	Напомним, что \textit{наибольшим общим делителем} (НОД) (англ. \texttt{greatest common divisor, GCD}) двух целых чисел $a$ и $b$ называется такое наибольшее натуральное число $g$, которое является делителем как $a$, так и $b$. Из курса занмата известно следующее утверждение:
	
	\stat{$\text{НОД}(a, b) = \text{НОД}(a - b, b)$}
	
	Или другое утверждение, которое является прямым следствием предыдущего:
	
	\stat{$\text{НОД}(a, b) = \text{НОД}(a \% b, b)$, где $\%$ означает оператор взятия остатка.}
	
	С помощью данного утверждения можно реализовать следующий алгоритм нахождения НОД двух натуральных чисел:
	
	\begin{enumerate}
		\item Даны два числа: $a$ и $b$.
		\item Повторять пока $b \ne 0$:
		
		\begin{enumerate}
			\item Если $b>a$, поменять $a$ и $b$ местами
			\item $a := a \% b$
		\end{enumerate}
		
		\item Вывести $a$.
	\end{enumerate}
	
	Доказательство корректности алгоритма (правильности его ответа и того, что он завершается за конечное число операций) оставим читателям как упражнение.
	
	Приведём наиболее ёмкую реализацию с помощью рекурсии:
	
	\begin{lstlisting}
int gcd(int a, int b) {
	if (b == 0) return a;
	return gcd(b, a % b);
}
	\end{lstlisting}
	
	\section{Дополнительные темы}
	
	\subsection{Что происходит, когда мы запускаем код?}
	
	У C++ есть важное отличие от, например, Python или Java. C++ --- \textit{компилируемый} язык программирования, в отличие от Python, \textit{интерпретируемого} языка программирования. Программа на C++ сначала переводится в \textit{байт-код} (например, \texttt{.exe}-файл), а затем байт-код выполняется операционной системой. Процесс перевода называется \textit{компиляцией}, а программа, его осуществляющая --- \textit{компилятором}. Байт-код --- это некоторая последовательность примитивных инструкций, которая отличается от \textit{машинного кода} тем, что она зависит только от операционной системы, но не от процессора. В этой универсальности и состоит преимущество байт-кода над машинным кодом.
	
	Программа на Python выполняется сразу из исходного кода, что значительно замедляет этот процесс. Поэтому Python --- \textit{интерпретируемый} язык.
	
	С Java все ещё более интересно. Она компилируется в свой байт-код, который не зависит от ОС, а затем этот байт-код выполняется в виртуальной машине (JVM).
	
	\subsection{Компиляция через терминал (Linux)}
	\label{sec:cmd-compile}
	
	Чтобы установить компилятор \texttt{GNU GCC}, введите в терминале \texttt{sudo apt-get install g++} (в случае, если в вашей ОС другой пакетный менеджер, используйте его). Чтобы скомпилировать программу, надо ввести команду \texttt{g++ <имя файла>.cpp}, где вместо \texttt{<имя файла>} надо указать название вашего файла. В таком случае будет создан файл \texttt{a.out}. Чтобы выбрать имя для исполняемого файла, укажите флаг \texttt{-o <имя исполняемого файла>}, например, \texttt{g++ A.cpp -o A}. Существуют и другие флаги. Наиболее распространённые их комбинации приведены в таблице.
	
	\begin{table}[H]
		\centering
		\begin{tabularx}{\textwidth}{|X|X|}
			\hline
			\texttt{-Wall -Wextra -Wunused -Wconversion} & Включает предупреждения (варнинги). Иногда помогают найти ошибки, так как показывают, например, неиспользованные переменные, неявные преобразования между типами, повторное использование одного и того же названия несколько раз.\\
			\hline
			\texttt{-O3} (латинская O и цифра 3) & Заставляет компилятор как можно сильнее оптимизировать код\\
			\hline
			\texttt{-fsanitize=undefined,bounds,address -g -g3} & Включает \textit{санитайзеры}, которые показывают ошибки во время исполнения (выход за границы массива, переполнение стека и т.д.)\\
			\hline
			\texttt{-DLOC} & Аналогично \texttt{\#define LOC} в самом начале вашего кода, помогает в дебаге, подробнее см. п. \ref{sec:defines}.\\
			\hline
		\end{tabularx}
	\end{table}
	
	\subsection{Установка и использование VS Code (Linux)}
	
	\begin{enumerate}
		\item {Установите компилятор \texttt{GNU GCC}. Для этого введите команду \texttt{sudo apt-get install g++} в терминале (в случае, если в вашей ОС нет \texttt{apt-get}, используйте менеджер пакетов вашей ОС).}
		\item {Установите VS Code с официального сайта (в случае Ubuntu вы можете установить его из Software Center):\\ {\color{blue}\href{https://code.visualstudio.com/}{https://code.visualstudio.com/}}.}
		\item {Установите расширение \texttt{C/C++ Extension Pack}. Для этого слева нажмите на иконку \includegraphics[height=14pt]{vsc1}, введите название в строке поиска и установите расширение.}
		\item {Запуск программы осуществляется через нажатие иконки \includegraphics[height=14pt]{vsc2} (или клавиши \texttt{F5}) или через командную строку (см. п. \ref{sec:cmd-compile}).}
	\end{enumerate}
	
	\subsection{Файловый ввод-вывод}
	\label{sec:files}
	
	В некоторых задачах требуется читать входные данные из одного файла, а записывать в другой. Насколько мне известно, это было популярно в середине 2010-х годов. Познакомимся с двумя способами работать с файлами.
	
	\subsubsection{\texttt{freopen}}
	
	Если вам нужно сделать так, чтобы потоки \texttt{cin} и \texttt{cout} работали с файлами (\textit{перенаправить потоки ввода-вывода}), то в начале функции \texttt{main} нужно дописать:
	
	\begin{lstlisting}
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
	\end{lstlisting}
	
	Вместо \texttt{input.txt} и \texttt{output.txt} нужно использовать имена файлов, указанные в условии задачи.
	
	\subsubsection{Потоки \texttt{ifstream}, \texttt{ofstream}}
	
	Этот способ более универсален, так как позволяет работать с большим количеством файлов. Для работы с файлами этим способом требуется добавить строку \texttt{\#include <fstream>}. Чтобы работать с файлом для чтения и записи соответственно, напишите:
	
	\begin{lstlisting}
ifstream name_in("file_name");
ofstream name_out("file_name");
	\end{lstlisting}
	
	Вместо \texttt{file\_name} надо указать имя файла, вместо \texttt{name\_in}, \texttt{name\_out} --- любые имена для этих потоков. Работа с ними осуществляется так же, как и с \texttt{cin} и \texttt{cout} --- через \texttt{>{}>} и \texttt{<{}<}. Приведённые ниже два кода решают задачу нахождения суммы двух чисел, читая ввод из \texttt{in.txt} и записывая вывод в \texttt{out.txt}:

	\begin{lstlisting}
#include <iostream>

using namespace std;

int main() {
	freopen("in.txt", "r", stdin);
	freopen("out.txt", "w", stdout);
	int a, b;
	cin >> a >> b;
	cout << a + b;
}
	\end{lstlisting}

	\begin{lstlisting}
#include <fstream>

using namespace std;

ifstream fin("in.txt");
ofstream fout("out.txt");

int main() {
	int a, b;
	fin >> a >> b;
	fout << a + b;
}
	\end{lstlisting}
	
	\subsection{Интерактивные задачи}
	\label{sec:interactive}

	До этого мы сталкивались только со стандартными задачами: весь ввод дан нам в самом начале выполнения программы. Встречается и другой формат задач: \textit{интерактивные задачи}. Их отличие состоит в том, что программа-решение взаимодействует с программой жюри (называемой \textit{интерактором}) через стандартные потоки ввода-вывода. Рассмотрим пример интерактивной задачи:

	\task{Жюри загадало натуральное число от $1$ до $10$. Угадайте его. Вы можете называть число, а интерактор будет отвечать вам $1$, если вы угадали, и $0$ иначе. Если вы угадали, Ваша программа должна немедленно завершиться. Вы можете сделать $10$ запросов.}

	\begin{lstlisting}
#include<iostream>

using namespace std;

int main() {
	for (int i = 1; i <= 10; i++) {
		cout << i << '\n';
		cout.flush();
		int x;
		cin >> x;
		if (x == 1) {
			return 0;
		}
	}
}
	\end{lstlisting}

	Обратите внимание на строку \texttt{cout.flush();}. Она осуществляет \textit{сброс буфера потока вывода}.

	Для ускорения вывода C++ выводит данные на экран не сразу при выполнении команды \texttt{cout}, а накапливает их в буфере, а затем выводит. Команда \texttt{cout.flush()} осуществляет вывод всего содержимого буфера.

	\note{Интерактивные задачи часто используют идею \textit{бинарного поиска}, с которой вы познакомитесь в следующем году.}

	\subsection{Поиск ошибок с помощью \texttt{assert}}

	При написании большого кода, к сожалению, часто допускаются ошибки. С определением места, где они возникают, может помочь функция \texttt{assert}. Чтобы её использовать, нужно подключить библиотеку \texttt{cassert}. Функция \texttt{assert} принимает аргумент типа \texttt{bool}. Если аргумент равен Истине, то продолжается выполнение кода. Если же он равен Лжи, то программа завершается, выдав ошибку. Таким образом, посылка в тестирующей системе получит вердикт Ошибка исполнения, а не Неправильный ответ.

	\subsection{Как сократить код?}

	Название типов часто довольно длинные, например, \texttt{long long}, \texttt{long double}, \texttt{vector<int>}. Поэтому часто используются сокращения, например, \texttt{ll}, \texttt{ld}, \texttt{vi}. Чтобы объяснить компилятору, что мы имели в виду, есть несколько способов:

	\subsubsection{\texttt{using}}

	Пример:

	\begin{lstlisting}
#include <iostream>

using namespace std;
using ll = long long;

int main() {
	ll a, b;
	cin >> a >> b;
	cout << a + b;
}
	\end{lstlisting}

	Этот подход считается лучшим, но имеет важные ограничения: он позволяет сокращать только типы. 

	\subsubsection{\texttt{\#define}}
	\label{sec:defines}

	Инструкции, начинающиеся с \texttt{\#}, выполняются во время \textit{препроцессинга}, этапа сборки программы, подготавливающего код к компиляции. Например, во время препроцессинга код всех подключенных библиотек вставляется в исходный код компилируемой программы. Такие инструкции называются \textit{директивами препроцессора}.
	
	Кроме того, во время препроцессинга происходит подстановка \texttt{\#define}. Если в коде мы укажем директиву
	
	\begin{center}
		\texttt{\#define E1 E2},
	\end{center}
	
	то в коде все вхождения \texttt{E1} заменятся на \texttt{E2}. Выражение \texttt{E1} должно быть токеном (т.е. должно быть корректным именем переменной: не содержать пробелов и т.д.), но выражение \texttt{E2} может быть произвольным.
	
	Этот способ позволяет сокращать не только названия типов, но и любые названия, например, методов.

	\begin{lstlisting}
#include <iostream>
#include <vector>

using namespace std;

#define bg begin

int main() {
	vector<int> v = {5, 4};
	cout << *v.bg(); // 5
}
	\end{lstlisting}

	В таком случае говорят, что объявлен \textit{макрос} \texttt{bg}.
	
	Бывают и функции-макросы:

	\begin{lstlisting}
#include <iostream>

using namespace std;

#define sq(x) ((x) * (x))

int main() {
	cout << sq(5 + 3); // 64
}
	\end{lstlisting}

	Запись выше означает, что \texttt{sq(x)} будет преобразовано в \texttt{((x) * (x))}.

	\important{Скобки лишними не бывают!}

	Посмотрим, что будет, если убрать скобки:

	\begin{lstlisting}
#include <iostream>

using namespace std;

#define sq(x) x * x

int main() {
	cout << sq(5 + 3); // 23
}
	\end{lstlisting}

	Вывод изменился. Чтобы разобраться с причинами, посмотрим, во что превратится 8 строчка после замены:

	\begin{lstlisting}
	cout << 5 + 3 * 5 + 3;
	\end{lstlisting}

	Таким образом, \texttt{\#define} работает <<в лоб>>, поэтому скобки очень важны.

	\texttt{\#define} часто используется для поиска ошибок в программе (дебага):

	\begin{lstlisting}
#include <iostream>

using namespace std;

#define debug(x) cout << #x << " = " << x << '\n';

int main() {
	int x = 5;
	debug(x); // x = 5
	debug(x + 1) // x + 1 = 6
	debug("Hello") // "Hello" = Hello
}
	\end{lstlisting}

	В случае объявления макроса, \# перед названием его аргумента означает <<вставь сюда строку, которая соответствует тому, что было передано в макрос>>.
	
	В процессе компиляции можно изменять вставляемые блоки кода в зависимости от того, определены ли некоторые константы. Для этого используются директивы \texttt{\#ifdef}, \texttt{\#else}, \texttt{\#endif}.
	
	\subsection{Неасимптотические оптимизации}
	
	Вероятно, этот раздел не пригодится вам на начальном этапе, но он полезен в дальнейшем.
	
	Часто бывает так, что коду не хватает чуть-чуть скорости, чтобы уложиться в лимит по времени, при этом алгоритм можно оставить тем же, но описать его немного иначе.
	
	\subsubsection{Быстрый ввод---вывод}
	
	В начале функции \texttt{main} можно указать следующие строки:
	
	\begin{lstlisting}
ios::sync_with_stdio(false);
cin.tie(nullptr);
	\end{lstlisting}
	
	Эти две строки соответственно делают следующее:
	
	\begin{enumerate}
		\item Выключает синхронизацию между потоками языка C++ (\texttt{cin}/\texttt{cout}) и языка Си (\texttt{scanf}/\texttt{printf}).
		\item Выключает <<очистку буфера>> вывода перед каждой операцией ввода\footnote{C++ не осуществляет вывод сразу, а накапливает в буфере, а затем выводит всё сразу. По умолчанию вывод (\textit{сброс буфера}) осуществляется при вызове \texttt{cout.flush()}, выводе \texttt{endl} и выполнении считывания через \texttt{cin}.}.
	\end{enumerate}
	
	\important{При большом объёме ввода эти две строчки необходимы, и правильное решение без них может получать вердикт <<Превышено время работы>>.}
	
	\subsubsection{Статические массивы}
	
	Статические массивы менее удобны, чем векторы, но они работают быстрее.
	
\end{document}
